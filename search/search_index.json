{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WLTools: Language Specification \u00b6 The purpose of this wiki is to rigorously describe Wolfram Language to assist authors of Wolfram Language tools and students of programming languages. Despite its widespread use in academia and industry, Wolfram Language has no formal specification . This website is an attempt to fix that. If you are looking for user documentation or a programming tutorial , you are in the wrong place. Would you like to help construct a language specification for Wolfram Language? We invite contributions from anyone. It's as easy as clicking \" Edit on GitHub \" and writing some Markdown . A good place to start is the Contributing page. Hit us up on... Slack Workspace: https://wolfr.am/y0c73dZg GitHub: https://github.com/WLTools Unfortunately, GitHub requires organization members to be \"invited\" by email or GitHub username, but I intend it to be open to anyone who wishes to participate. Hit us up on Slack. Table of Contents \u00b6 Language Specification Syntax Primitives Strings Number representations Symbols (identifiers) Special character representations Operators Variadic forms Operators with a built-in meaning List of all operators with precedence, associativity, affix, and arity Two-dimensional \"operators\" FullForm (M-expressions) Pseudo-operators Formatting and whitespace Box sublanguage Issues and inconsistencies Precedence FullForm interpretation Nonexpression objects (\"atomic functions\") Bugs Semantics Symbol properties OwnValues DownValues, UpValues DefaultValues Options Attributes Messages SubValues NValues FormatValues Scoping rules Scoping operators Contexts \u03bb calculus semantics Packages Pattern matching Patterns Types of equality Options Evaluation Types Number literal semantics Messages Homoiconicity Standard Library Manipulating primitives and expressions \"List\" processing and functional programming Homoiconic functions Introspection Strings Numbers Control flow Controlling evaluation IO Mathematics Graphics UI Typesetting System and Environment Autoevaluating symbols Interfaces Notebook REPL Applications WSTP WXF Resources for implementors General advice for implementors Exploring Mathematica List of Independent Wolfram Language Projects Test suite derived from this wiki Implementing pattern matching Python Go ML-like languages Parsing strategies Functional language implementation WL code highlighters and editors This website and its authors are not affiliated with Wolfram LLC in any way.","title":"WLTools: Language Specification"},{"location":"#wltools-language-specification","text":"The purpose of this wiki is to rigorously describe Wolfram Language to assist authors of Wolfram Language tools and students of programming languages. Despite its widespread use in academia and industry, Wolfram Language has no formal specification . This website is an attempt to fix that. If you are looking for user documentation or a programming tutorial , you are in the wrong place. Would you like to help construct a language specification for Wolfram Language? We invite contributions from anyone. It's as easy as clicking \" Edit on GitHub \" and writing some Markdown . A good place to start is the Contributing page. Hit us up on... Slack Workspace: https://wolfr.am/y0c73dZg GitHub: https://github.com/WLTools Unfortunately, GitHub requires organization members to be \"invited\" by email or GitHub username, but I intend it to be open to anyone who wishes to participate. Hit us up on Slack.","title":"WLTools: Language Specification"},{"location":"#table-of-contents","text":"Language Specification Syntax Primitives Strings Number representations Symbols (identifiers) Special character representations Operators Variadic forms Operators with a built-in meaning List of all operators with precedence, associativity, affix, and arity Two-dimensional \"operators\" FullForm (M-expressions) Pseudo-operators Formatting and whitespace Box sublanguage Issues and inconsistencies Precedence FullForm interpretation Nonexpression objects (\"atomic functions\") Bugs Semantics Symbol properties OwnValues DownValues, UpValues DefaultValues Options Attributes Messages SubValues NValues FormatValues Scoping rules Scoping operators Contexts \u03bb calculus semantics Packages Pattern matching Patterns Types of equality Options Evaluation Types Number literal semantics Messages Homoiconicity Standard Library Manipulating primitives and expressions \"List\" processing and functional programming Homoiconic functions Introspection Strings Numbers Control flow Controlling evaluation IO Mathematics Graphics UI Typesetting System and Environment Autoevaluating symbols Interfaces Notebook REPL Applications WSTP WXF Resources for implementors General advice for implementors Exploring Mathematica List of Independent Wolfram Language Projects Test suite derived from this wiki Implementing pattern matching Python Go ML-like languages Parsing strategies Functional language implementation WL code highlighters and editors This website and its authors are not affiliated with Wolfram LLC in any way.","title":"Table of Contents"},{"location":"Contributing/","text":"How to Contribute \u00b6 Would you like to help construct a language specification for Wolfram Language? It's as easy as clicking \" Edit on GitHub \" and writing some Markdown . Just click on the index page of any category to find a place to start. If you have content but don't yet know where it should go, put it in the Homeless Content page . Hit us up on... Slack Workspace: https://wolfr.am/y0c73dZg GitHub: https://github.com/WLTools Unfortunately, GitHub requires organization members to be \"invited\" by email or GitHub username, but I intend it to be open to anyone who wishes to participate. Hit us up on Slack. Writing Content \u00b6 If you do not yet have write access to this repository, you should use the usual GitHub workflow outlined below. Get the Content \u00b6 Fork the repository on GitHub . Then grab a local copy of your fork: $ git clone git@github.com:yourusername/LanguageSpec.git Writing \u00b6 The content is written in Markdown files in a folder hierarchy in the docs directory. We have a style guide to help us write consistently. The style guide also explains how to typeset mathematics and other special content. If you add a file and want it to appear in the navigation menu, edit the mkdocs.yml file in the repository's root directory and include the file you want to add under nav following the existing examples. Giving Back \u00b6 Finally, commit and push your changes: $ git commit -m \"A meaningful commit message about the changes here.\" $ git push origin master Then create a pull request on GitHub. Done! Modifying the Website Theme or Structure \u00b6 You probably won't need to modify the theme or structure of the website. The site is statically generated with MkDocs . We use the built-in Read The Docs theme. MkDocs is Python based, so we need a few pip install 's. As usual, you will want to create a new Python 3 virtual environment. Then install MkDocs and a couple of libraries for code highlighting and Markdown extensions: $ pip install mkdocs pygments pymdown-extensions markdown-include If you haven't already, fork the repository on GitHub , and grab a local copy of your fork: $ git clone git@github.com:yourusername/LanguageSpec.git The left hand navigation is specified in the mkdocs.yml file.","title":"How to Contribute"},{"location":"Contributing/#how-to-contribute","text":"Would you like to help construct a language specification for Wolfram Language? It's as easy as clicking \" Edit on GitHub \" and writing some Markdown . Just click on the index page of any category to find a place to start. If you have content but don't yet know where it should go, put it in the Homeless Content page . Hit us up on... Slack Workspace: https://wolfr.am/y0c73dZg GitHub: https://github.com/WLTools Unfortunately, GitHub requires organization members to be \"invited\" by email or GitHub username, but I intend it to be open to anyone who wishes to participate. Hit us up on Slack.","title":"How to Contribute"},{"location":"Contributing/#writing-content","text":"If you do not yet have write access to this repository, you should use the usual GitHub workflow outlined below.","title":"Writing Content"},{"location":"Contributing/#get-the-content","text":"Fork the repository on GitHub . Then grab a local copy of your fork: $ git clone git@github.com:yourusername/LanguageSpec.git","title":"Get the Content"},{"location":"Contributing/#writing","text":"The content is written in Markdown files in a folder hierarchy in the docs directory. We have a style guide to help us write consistently. The style guide also explains how to typeset mathematics and other special content. If you add a file and want it to appear in the navigation menu, edit the mkdocs.yml file in the repository's root directory and include the file you want to add under nav following the existing examples.","title":"Writing"},{"location":"Contributing/#giving-back","text":"Finally, commit and push your changes: $ git commit -m \"A meaningful commit message about the changes here.\" $ git push origin master Then create a pull request on GitHub. Done!","title":"Giving Back"},{"location":"Contributing/#modifying-the-website-theme-or-structure","text":"You probably won't need to modify the theme or structure of the website. The site is statically generated with MkDocs . We use the built-in Read The Docs theme. MkDocs is Python based, so we need a few pip install 's. As usual, you will want to create a new Python 3 virtual environment. Then install MkDocs and a couple of libraries for code highlighting and Markdown extensions: $ pip install mkdocs pygments pymdown-extensions markdown-include If you haven't already, fork the repository on GitHub , and grab a local copy of your fork: $ git clone git@github.com:yourusername/LanguageSpec.git The left hand navigation is specified in the mkdocs.yml file.","title":"Modifying the Website Theme or Structure"},{"location":"Contributing/Homeless-content/","text":"Homeless Contents \u00b6 This is a catch-all document for content that should be incorporated somewhere but for one reason or another has not yet found the right place. Homeless Contents Documentation, examples, test suites Mathematica behaviors / quirks Different behavior between ToExpression vs command line Frontend RawEscape is as a letter Documentation, examples, test suites \u00b6 Cory Walker's test suite and documentation : Together Documentation Together Documentation Source Mathematica behaviors / quirks \u00b6 Different behavior between ToExpression vs command line \u00b6 The command line and ToExpression nearly always give the same output. Here are two examples where ToExpression does not match the command line. Command line: In [ 1 ] := 2` `\\ : 22127 Out [ 1 ] = 2 ToExpression : In [ 1 ] := ToExpression [ \"2``\\\\:\" <> \"22127\" ] Out [ 1 ] = $Failed On the command line, the following either emits a UTF-8 character encoding error and crashes or else results in the following (notice the skipped In / Out number): In [ 1 ] := 2` `\\[Minus] 7 Out [ 3 ] = 2 ToExpression : In [ 1 ] := ToExpression [ \"2``\\\\[\" <> \"Minus]7\" ] Out [ 1 ] = $Failed Frontend \u00b6 RawEscape is as a letter \u00b6 From: https://wolframlanguage.slack.com/archives/CDQJUDQ11/p1541094222036400 \\[RawEscape] is supposed to be a letter-like character. Note also that \\[RawEscape] is listed as a letter in UnicodeCharacters.tr . However, the FE has a hard time with it. MathLink`CallFrontEnd [ FrontEnd`UndocumentedTestFEParserPacket [ \"a\\[RawEscape]a\" , False ]] The FE allows \\[RawEscape] to begin a symbol name but not to end a symbol name. The FE interprets as \\[RawEscape] at the end as implicit multiplication. The command line does not have this problem, i.e. it treats \\[RawEscape] as a letter without issue.","title":"Homeless Contents"},{"location":"Contributing/Homeless-content/#homeless-contents","text":"This is a catch-all document for content that should be incorporated somewhere but for one reason or another has not yet found the right place. Homeless Contents Documentation, examples, test suites Mathematica behaviors / quirks Different behavior between ToExpression vs command line Frontend RawEscape is as a letter","title":"Homeless Contents"},{"location":"Contributing/Homeless-content/#documentation-examples-test-suites","text":"Cory Walker's test suite and documentation : Together Documentation Together Documentation Source","title":"Documentation, examples, test suites"},{"location":"Contributing/Homeless-content/#mathematica-behaviors-quirks","text":"","title":"Mathematica behaviors / quirks"},{"location":"Contributing/Homeless-content/#different-behavior-between-toexpression-vs-command-line","text":"The command line and ToExpression nearly always give the same output. Here are two examples where ToExpression does not match the command line. Command line: In [ 1 ] := 2` `\\ : 22127 Out [ 1 ] = 2 ToExpression : In [ 1 ] := ToExpression [ \"2``\\\\:\" <> \"22127\" ] Out [ 1 ] = $Failed On the command line, the following either emits a UTF-8 character encoding error and crashes or else results in the following (notice the skipped In / Out number): In [ 1 ] := 2` `\\[Minus] 7 Out [ 3 ] = 2 ToExpression : In [ 1 ] := ToExpression [ \"2``\\\\[\" <> \"Minus]7\" ] Out [ 1 ] = $Failed","title":"Different behavior between ToExpression vs command line"},{"location":"Contributing/Homeless-content/#frontend","text":"","title":"Frontend"},{"location":"Contributing/Homeless-content/#rawescape-is-as-a-letter","text":"From: https://wolframlanguage.slack.com/archives/CDQJUDQ11/p1541094222036400 \\[RawEscape] is supposed to be a letter-like character. Note also that \\[RawEscape] is listed as a letter in UnicodeCharacters.tr . However, the FE has a hard time with it. MathLink`CallFrontEnd [ FrontEnd`UndocumentedTestFEParserPacket [ \"a\\[RawEscape]a\" , False ]] The FE allows \\[RawEscape] to begin a symbol name but not to end a symbol name. The FE interprets as \\[RawEscape] at the end as implicit multiplication. The command line does not have this problem, i.e. it treats \\[RawEscape] as a letter without issue.","title":"RawEscape is as a letter"},{"location":"Contributing/Style-Guide/","text":"Style Guide \u00b6 Use GitHub Flavored Markdown . Writing Style Guide \u00b6 Write in standard written English in approximation to Wikipedia's Manual of Style . In particular, \"Style and formatting should be consistent within an article.\" Special Symbols \u00b6 Almost every editor and browser can handle characters outside of the ASCII character set. Feel free to use either an html entity &sum; , decimal reference &#8721; , hex reference &#x2211; , or the character itself \u2211. Note that Mathematica makes use of Unicode code points that do not represent the characters Mathematica displays. For example, \\[WolframLanguageLogo] is the codepoint &#61726; which is marked \"for private use\"\u2014it is not a valid Unicode character and renders as \uf11e. For these cases, it is best to use the long name: \\[WolframLanguageLogo] . Mathematical Typesetting \u00b6 Inline math is typeset between single $ -signs. Thus, $ \\sqrt { 1 + x^ 2 } $ renders as \\(\\sqrt{1+x^2}\\) . Likewise, use $$\u2026$$ or \\[\u2026\\] for displayed math: $$ x = { \\frac { - b \\pm { \\sqrt {b^{ 2 } - 4 ac}}}{ 2 a}} $$ renders as \\[x={\\frac {-b\\pm {\\sqrt {b^{2}-4ac}}}{2a}}.\\] Important A displayed math equation needs to be surrounded by newlines as if it were in its own paragraph. Code Style Guide \u00b6 Place code within a code fence with the explicit language identifier. For example, ```wl StringJoin[Capitalize[ToLowerCase[StringSplit[\"my list\"]]]] ``` results in the following: StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ \"my list\" ]]]] Set off code within text by placing it between two backticks ( ` ), optionally with an inline language specifier: `#!wl f[N@{g/@m}]` is rendered as f [ N @ { g /@ m }] . The language specifiers are typically just the language name (see the Pygments docs ): python , c , cpp , latex , perl (for regexes), antlr (for grammars), python , java . Use wl , not mma or mathematica , as the language identifier for WL. Formal Grammars \u00b6 The rule of thumb is that formal grammar representations should be considered pseudocode unless explicitly labelled otherwise. We express formal grammars in the usual syntax of Flex and Bison but allow regular expressions to be included within productions. Even so, we may capitalize purely lexical rules as is tradition. Productions end with a semicolon. Following ANTLR4 syntax , productions that can only appear within another production may be marked with fragment . This can make complicated productions easier to read while communicating that the fragment cannot appear on its own. Thus, a simplified example might be: fragment DIGIT : [ 0-9 ]; DecimalNumber : DIGIT + '.' DIGIT * ; On occassions when a pure Bison, Flex, ANTLR4, or other specific grammar syntax is intended, the grammar should be labelled with its specific grammar syntax. Likewise, a pure regular expression should be labelled as such. If you use features in a regular expression that are specific to a particular syntax standard (PCRE, POSIX, Perl), please indicate the syntax standard you are using. WL Code \u00b6 A WL expression (almost) always evaluates to another valid WL expression, so it is necessary to distinguish input expressions from output expressions using the In [ 1 ] := and Out [ 2 ] = labels respectively, just as the Mathematica command line interface does: In [ 1 ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ \"my list\" ]]]] Out [ 1 ] = \"MyList\" An alternative to the above is to place the expected output of the expression in a code comment immediately below the expression. This has the disadvantage that the output is not syntax highlighted. StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ \"my list\" ]]]] (* \"MyList\" *) It is often useful to write the output of an evaluation differently from how Mathematica would display it by default. In the examples above, \"MyList\" is written within double quotes, i.e. in InputForm , to make it clear that the result is a string. It is not necessary to write Out [ 4 ] // InputForm = \"MyList\" in these cases. GFM does not word-wrap WL code. For long lines of code, adding a linebreak improves readability and prevents an ugly scrollbar from appearing in the code block. Indent the continuation to make it clear that it is a continuation of the expression. In [ 1 ] := toCamelCase [ str_String ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ str ]]]] WL encourages writing code that is difficult to read. A little bit of whitespace can make a big difference. In [ 1 ] := toCamelCase [ str_String ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ str ] ] ] ] Always put code that is included inline in a sentence between backticks: writing `#!wl PrimeQ/@Range[20]` renders as PrimeQ /@ Range [ 20 ] . Only short pieces of code should be inlined. For example, PrimeQ /@ Range [ 20 ] is ok, but toCamelCase [ str_String ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ str ]]]] is too long. When writing a specification for WL, always make note of where there can be incompatibilities with Mathematica using a \"Compatibility Warning\" as described in the next section. Admonitions \u00b6 We use the (Admonitions plugin)[ https://python-markdown.github.io/extensions/admonition/ ] for MKDocs which provides the following admonition environments: Important , Abstract , Info , Tip , Success , Question , Warning , Failure , Danger , Bug , Example , and Quote . Writing !!! warning \"Compatibility Warning\" This is a warning about compatibility with Mathematica. will render as Compatibility Warning This is a warning about compatibility with Mathematica. Authorship \u00b6 If you author an article, feel free to add a byline. If you add significantly to an article with a byline, feel free to add your name to the byline. Neither is required.","title":"Style Guide"},{"location":"Contributing/Style-Guide/#style-guide","text":"Use GitHub Flavored Markdown .","title":"Style Guide"},{"location":"Contributing/Style-Guide/#writing-style-guide","text":"Write in standard written English in approximation to Wikipedia's Manual of Style . In particular, \"Style and formatting should be consistent within an article.\"","title":"Writing Style Guide"},{"location":"Contributing/Style-Guide/#special-symbols","text":"Almost every editor and browser can handle characters outside of the ASCII character set. Feel free to use either an html entity &sum; , decimal reference &#8721; , hex reference &#x2211; , or the character itself \u2211. Note that Mathematica makes use of Unicode code points that do not represent the characters Mathematica displays. For example, \\[WolframLanguageLogo] is the codepoint &#61726; which is marked \"for private use\"\u2014it is not a valid Unicode character and renders as \uf11e. For these cases, it is best to use the long name: \\[WolframLanguageLogo] .","title":"Special Symbols"},{"location":"Contributing/Style-Guide/#mathematical-typesetting","text":"Inline math is typeset between single $ -signs. Thus, $ \\sqrt { 1 + x^ 2 } $ renders as \\(\\sqrt{1+x^2}\\) . Likewise, use $$\u2026$$ or \\[\u2026\\] for displayed math: $$ x = { \\frac { - b \\pm { \\sqrt {b^{ 2 } - 4 ac}}}{ 2 a}} $$ renders as \\[x={\\frac {-b\\pm {\\sqrt {b^{2}-4ac}}}{2a}}.\\] Important A displayed math equation needs to be surrounded by newlines as if it were in its own paragraph.","title":"Mathematical Typesetting"},{"location":"Contributing/Style-Guide/#code-style-guide","text":"Place code within a code fence with the explicit language identifier. For example, ```wl StringJoin[Capitalize[ToLowerCase[StringSplit[\"my list\"]]]] ``` results in the following: StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ \"my list\" ]]]] Set off code within text by placing it between two backticks ( ` ), optionally with an inline language specifier: `#!wl f[N@{g/@m}]` is rendered as f [ N @ { g /@ m }] . The language specifiers are typically just the language name (see the Pygments docs ): python , c , cpp , latex , perl (for regexes), antlr (for grammars), python , java . Use wl , not mma or mathematica , as the language identifier for WL.","title":"Code Style Guide"},{"location":"Contributing/Style-Guide/#formal-grammars","text":"The rule of thumb is that formal grammar representations should be considered pseudocode unless explicitly labelled otherwise. We express formal grammars in the usual syntax of Flex and Bison but allow regular expressions to be included within productions. Even so, we may capitalize purely lexical rules as is tradition. Productions end with a semicolon. Following ANTLR4 syntax , productions that can only appear within another production may be marked with fragment . This can make complicated productions easier to read while communicating that the fragment cannot appear on its own. Thus, a simplified example might be: fragment DIGIT : [ 0-9 ]; DecimalNumber : DIGIT + '.' DIGIT * ; On occassions when a pure Bison, Flex, ANTLR4, or other specific grammar syntax is intended, the grammar should be labelled with its specific grammar syntax. Likewise, a pure regular expression should be labelled as such. If you use features in a regular expression that are specific to a particular syntax standard (PCRE, POSIX, Perl), please indicate the syntax standard you are using.","title":"Formal Grammars"},{"location":"Contributing/Style-Guide/#wl-code","text":"A WL expression (almost) always evaluates to another valid WL expression, so it is necessary to distinguish input expressions from output expressions using the In [ 1 ] := and Out [ 2 ] = labels respectively, just as the Mathematica command line interface does: In [ 1 ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ \"my list\" ]]]] Out [ 1 ] = \"MyList\" An alternative to the above is to place the expected output of the expression in a code comment immediately below the expression. This has the disadvantage that the output is not syntax highlighted. StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ \"my list\" ]]]] (* \"MyList\" *) It is often useful to write the output of an evaluation differently from how Mathematica would display it by default. In the examples above, \"MyList\" is written within double quotes, i.e. in InputForm , to make it clear that the result is a string. It is not necessary to write Out [ 4 ] // InputForm = \"MyList\" in these cases. GFM does not word-wrap WL code. For long lines of code, adding a linebreak improves readability and prevents an ugly scrollbar from appearing in the code block. Indent the continuation to make it clear that it is a continuation of the expression. In [ 1 ] := toCamelCase [ str_String ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ str ]]]] WL encourages writing code that is difficult to read. A little bit of whitespace can make a big difference. In [ 1 ] := toCamelCase [ str_String ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ str ] ] ] ] Always put code that is included inline in a sentence between backticks: writing `#!wl PrimeQ/@Range[20]` renders as PrimeQ /@ Range [ 20 ] . Only short pieces of code should be inlined. For example, PrimeQ /@ Range [ 20 ] is ok, but toCamelCase [ str_String ] := StringJoin [ Capitalize [ ToLowerCase [ StringSplit [ str ]]]] is too long. When writing a specification for WL, always make note of where there can be incompatibilities with Mathematica using a \"Compatibility Warning\" as described in the next section.","title":"WL Code"},{"location":"Contributing/Style-Guide/#admonitions","text":"We use the (Admonitions plugin)[ https://python-markdown.github.io/extensions/admonition/ ] for MKDocs which provides the following admonition environments: Important , Abstract , Info , Tip , Success , Question , Warning , Failure , Danger , Bug , Example , and Quote . Writing !!! warning \"Compatibility Warning\" This is a warning about compatibility with Mathematica. will render as Compatibility Warning This is a warning about compatibility with Mathematica.","title":"Admonitions"},{"location":"Contributing/Style-Guide/#authorship","text":"If you author an article, feel free to add a byline. If you add significantly to an article with a byline, feel free to add your name to the byline. Neither is required.","title":"Authorship"},{"location":"Resources/","text":"Resources for implementors \u00b6 This is what still needs documenting. Want to help ? Specification Coverage General advice for implementors Exploring Mathematica List of Independent Wolfram Language Projects Test suite derived from this wiki Implementing pattern matching Python Go ML-like languages Parsing strategies Functional language implementation WL code highlighters and editors","title":"Index"},{"location":"Resources/#resources-for-implementors","text":"This is what still needs documenting. Want to help ? Specification Coverage General advice for implementors Exploring Mathematica List of Independent Wolfram Language Projects Test suite derived from this wiki Implementing pattern matching Python Go ML-like languages Parsing strategies Functional language implementation WL code highlighters and editors","title":"Resources for implementors"},{"location":"Resources/Exploring-Mathematica/","text":"Exploring Mathematica \u00b6 This pages points to ways of exploring Mathematica's implementation of Wolfram Language. To access the definition of a built-in function, simply use PrintDefinitions from the GeneralUtilities package. (You don\u2019t need the Spelunking Tools anymore.) In [ 1 ] := GeneralUtilities`PrintDefinitions [ GeneralUtilities`PrintDefinitions ] Out [ 1 ] = NotebookObject [ GeneralUtilities`PrintDefinitions ] Parsing Expressions \u00b6 The FE creates a box representation of your input as you type. The box representation then gets reinterpreted as an expression by the kernel. The FE often interprets input differently from the kernel. In particular, there are many cases of inconsistencies in operator precedence between the FE and ToExpression / command line. Therefore, we need ways of explicitly choosing which component parses an expression even if we are working in a notebook. Using the kernel to parse an expression \u00b6 Using ToExpression or the command line interface uses the kernel directly to parse the expression, circumventing the FE's parser. To make sure your expression is parsed by the kernel even if you are working in a notebook, do this: In [ 10 ] := FullForm [ ToExpression [ \"Hold[a|b*c]\" ]] Out [ 10 ] // FullForm = Hold [ Alternatives [ a , Times [ b , c ]]] It matters how you use ToExpression . Compare: In [ 1 ] := ToExpression [ \"a;;\\[Intersection]a\\[SquareIntersection];;a\" , StandardForm , Hold ] // FullForm Syntax :: sntxf : \"a;; \u22c2 a \u2293\" cannot be followed by \";;a\" . ToExpression :: sntx : Invalid syntax in or before \"\\!\\(StandardForm\\`a;;\\:22c2a\\:2293;;a\\) \" . ^ Out [ 1 ] // FullForm = $Failed gives a different result from In [ 1 ] := ToExpression [ \"Hold[a;;\\[Intersection]a\\[SquareIntersection];;a]\" ] // FullForm Out [ 1 ] // FullForm = Hold [ Span [ SquareIntersection [ Intersection [ Span [ a , All ], a ], System`Private`DummyId ], a ]] in both the FE and command line. Using the Frontend to parse an expression \u00b6 To ask the FE to interpret an expression given as a String , do this: FEToExpression [ s_String ] := MakeExpression @ FrontEndExecute @ FrontEnd`ReparseBoxStructurePacket [ s ] Alternatively, you can use the UndocumentedTestFEParserPacket function: FEToExpression [ s_String ] := MakeExpression [ MathLink`CallFrontEnd [ FrontEnd`UndocumentedTestFEParserPacket [ s , False ] ][[ 1 ]] (* Do not need form annotation. *) ] Note that UndocumentedTestFEParserPacket returns a list of the form {boxexpression, form} , where form is usually StandardForm .","title":"Exploring Mathematica"},{"location":"Resources/Exploring-Mathematica/#exploring-mathematica","text":"This pages points to ways of exploring Mathematica's implementation of Wolfram Language. To access the definition of a built-in function, simply use PrintDefinitions from the GeneralUtilities package. (You don\u2019t need the Spelunking Tools anymore.) In [ 1 ] := GeneralUtilities`PrintDefinitions [ GeneralUtilities`PrintDefinitions ] Out [ 1 ] = NotebookObject [ GeneralUtilities`PrintDefinitions ]","title":"Exploring Mathematica"},{"location":"Resources/Exploring-Mathematica/#parsing-expressions","text":"The FE creates a box representation of your input as you type. The box representation then gets reinterpreted as an expression by the kernel. The FE often interprets input differently from the kernel. In particular, there are many cases of inconsistencies in operator precedence between the FE and ToExpression / command line. Therefore, we need ways of explicitly choosing which component parses an expression even if we are working in a notebook.","title":"Parsing Expressions"},{"location":"Resources/Exploring-Mathematica/#using-the-kernel-to-parse-an-expression","text":"Using ToExpression or the command line interface uses the kernel directly to parse the expression, circumventing the FE's parser. To make sure your expression is parsed by the kernel even if you are working in a notebook, do this: In [ 10 ] := FullForm [ ToExpression [ \"Hold[a|b*c]\" ]] Out [ 10 ] // FullForm = Hold [ Alternatives [ a , Times [ b , c ]]] It matters how you use ToExpression . Compare: In [ 1 ] := ToExpression [ \"a;;\\[Intersection]a\\[SquareIntersection];;a\" , StandardForm , Hold ] // FullForm Syntax :: sntxf : \"a;; \u22c2 a \u2293\" cannot be followed by \";;a\" . ToExpression :: sntx : Invalid syntax in or before \"\\!\\(StandardForm\\`a;;\\:22c2a\\:2293;;a\\) \" . ^ Out [ 1 ] // FullForm = $Failed gives a different result from In [ 1 ] := ToExpression [ \"Hold[a;;\\[Intersection]a\\[SquareIntersection];;a]\" ] // FullForm Out [ 1 ] // FullForm = Hold [ Span [ SquareIntersection [ Intersection [ Span [ a , All ], a ], System`Private`DummyId ], a ]] in both the FE and command line.","title":"Using the kernel to parse an expression"},{"location":"Resources/Exploring-Mathematica/#using-the-frontend-to-parse-an-expression","text":"To ask the FE to interpret an expression given as a String , do this: FEToExpression [ s_String ] := MakeExpression @ FrontEndExecute @ FrontEnd`ReparseBoxStructurePacket [ s ] Alternatively, you can use the UndocumentedTestFEParserPacket function: FEToExpression [ s_String ] := MakeExpression [ MathLink`CallFrontEnd [ FrontEnd`UndocumentedTestFEParserPacket [ s , False ] ][[ 1 ]] (* Do not need form annotation. *) ] Note that UndocumentedTestFEParserPacket returns a list of the form {boxexpression, form} , where form is usually StandardForm .","title":"Using the Frontend to parse an expression"},{"location":"Resources/List-of-W-Language-Projects/","text":"List of Independent Wolfram Language Projects \u00b6 Computer Algebra Systems and Term Rewriters \u00b6 Active \u00b6 omath is similar in spirit to Mathics but is written in Java/Scala and appears to have had a 7 year hiatus from 2005 to 2012. The original parser \"is mostly written by Yossi Farjoun, with some help from Scott Morrison\" and is a generated parser using JavaCC and JJTree. There seems to be a newer parser written in Scala. The source code is distributed without a license. The historical repository lives at http://svn.omath.org/ . Mathics : A free, light-weight alternative to Mathematica created by Jan P\u00f6schko. A Mathematica clone written in Python, Mathics includes a complete parser, FullForm emitter, and evaluator. GPL3 license. cas : A \"bare bones cas\" and front end that \"tries to implement some of the mathematica language. A very limited set of commands is currently implemented.\" Written in C++. No license is specified. mmaclone : \"This interpreter is intended to mimic every exact detail of Wolfram Language, including but not limited to its syntax, semantic, expression structure, evaluation details, etc.\" Written in Haskell by Yonghao Jin. No license is specified. expreduce : A term rewriter/computer algebra system written in Go by Cory Walker using the WL parser by Jan Mercl. \"The term rewriting system and pattern matching engine is fairly advanced. The computer algebra system at this stage is extremely limited, but simple calculus and algebraic manipulation is certainly supported....\" MIT license. Inactive \u00b6 MockMMA : By Richard Fateman written in Lisp. This one's an old classic and of historical interest. basicCAS : By Alex Gittens, a python Mathematica parser. It appears to have disappeared from the author's website, but it's still available elsewhere on the net for those interested in looking for it. This project is interesting because it includes Alex's notes regarding implementation. Parsers \u00b6 Active \u00b6 FoxySheep . A relatively complete, easy to understand, easy to hack parser and FullForm emitter. Based on ANTLR4, FoxySheep targets Java and Python. Written by Robert Jacobson. BSD license. Mathematica IntelliJ Plugin . A mature, well-tested Wolfram Language parser capable of emitting FullForm and doing various code analysis. The parser is a beautiful example of a Pratt parser, a top-down operator precedence parsing strategy first described by Vaughan Pratt in the 70s. MIT license for the code, but also includes proprietary data that is Copyright \u00a9 2013 Wolfram Research, Inc., that is distributed under a restricted use license. Symja-parser is the Mathematica parser for Symja - Java Computer Algebra Library , \"a general purpose Java library for symbolic mathematics\" by Axel Kramer. Symja contains a Mathematica parser for a reasonable subset of Mathematica. Apache License. WL : A lex/yacc based parser written in Go by by Jan Mercl. BSD license. Inactive \u00b6 Mateusz Paprocki's Mathematica Parser in Scala : \"A library for parsing Mathematica's programming language written in Scala. It uses parser combinators and packrat parsers from Scala's standard library. Currently only a subset of Mathematica's language is supported.\" MIT Licensed.","title":"List of WL Projects"},{"location":"Resources/List-of-W-Language-Projects/#list-of-independent-wolfram-language-projects","text":"","title":"List of Independent Wolfram Language Projects"},{"location":"Resources/List-of-W-Language-Projects/#computer-algebra-systems-and-term-rewriters","text":"","title":"Computer Algebra Systems and Term Rewriters"},{"location":"Resources/List-of-W-Language-Projects/#active","text":"omath is similar in spirit to Mathics but is written in Java/Scala and appears to have had a 7 year hiatus from 2005 to 2012. The original parser \"is mostly written by Yossi Farjoun, with some help from Scott Morrison\" and is a generated parser using JavaCC and JJTree. There seems to be a newer parser written in Scala. The source code is distributed without a license. The historical repository lives at http://svn.omath.org/ . Mathics : A free, light-weight alternative to Mathematica created by Jan P\u00f6schko. A Mathematica clone written in Python, Mathics includes a complete parser, FullForm emitter, and evaluator. GPL3 license. cas : A \"bare bones cas\" and front end that \"tries to implement some of the mathematica language. A very limited set of commands is currently implemented.\" Written in C++. No license is specified. mmaclone : \"This interpreter is intended to mimic every exact detail of Wolfram Language, including but not limited to its syntax, semantic, expression structure, evaluation details, etc.\" Written in Haskell by Yonghao Jin. No license is specified. expreduce : A term rewriter/computer algebra system written in Go by Cory Walker using the WL parser by Jan Mercl. \"The term rewriting system and pattern matching engine is fairly advanced. The computer algebra system at this stage is extremely limited, but simple calculus and algebraic manipulation is certainly supported....\" MIT license.","title":"Active"},{"location":"Resources/List-of-W-Language-Projects/#inactive","text":"MockMMA : By Richard Fateman written in Lisp. This one's an old classic and of historical interest. basicCAS : By Alex Gittens, a python Mathematica parser. It appears to have disappeared from the author's website, but it's still available elsewhere on the net for those interested in looking for it. This project is interesting because it includes Alex's notes regarding implementation.","title":"Inactive"},{"location":"Resources/List-of-W-Language-Projects/#parsers","text":"","title":"Parsers"},{"location":"Resources/List-of-W-Language-Projects/#active_1","text":"FoxySheep . A relatively complete, easy to understand, easy to hack parser and FullForm emitter. Based on ANTLR4, FoxySheep targets Java and Python. Written by Robert Jacobson. BSD license. Mathematica IntelliJ Plugin . A mature, well-tested Wolfram Language parser capable of emitting FullForm and doing various code analysis. The parser is a beautiful example of a Pratt parser, a top-down operator precedence parsing strategy first described by Vaughan Pratt in the 70s. MIT license for the code, but also includes proprietary data that is Copyright \u00a9 2013 Wolfram Research, Inc., that is distributed under a restricted use license. Symja-parser is the Mathematica parser for Symja - Java Computer Algebra Library , \"a general purpose Java library for symbolic mathematics\" by Axel Kramer. Symja contains a Mathematica parser for a reasonable subset of Mathematica. Apache License. WL : A lex/yacc based parser written in Go by by Jan Mercl. BSD license.","title":"Active"},{"location":"Resources/List-of-W-Language-Projects/#inactive_1","text":"Mateusz Paprocki's Mathematica Parser in Scala : \"A library for parsing Mathematica's programming language written in Scala. It uses parser combinators and packrat parsers from Scala's standard library. Currently only a subset of Mathematica's language is supported.\" MIT Licensed.","title":"Inactive"},{"location":"Resources/tasks/","text":"- [ ] General advice for implementors - [x] [Exploring Mathematica](Exploring-Mathematica.md) - [x] [List of Independent Wolfram Language Projects](List-of-W-Language-Projects.md) - [ ] Test suite derived from this wiki - [ ] Implementing pattern matching - [ ] Python - [ ] Go - [ ] ML-like languages - [ ] Parsing strategies - [ ] Functional language implementation - [ ] WL code highlighters and editors","title":"Tasks"},{"location":"Specification/","text":"Language Specification \u00b6 Original home: https://github.com/WLTools/LanguageSpec.git The purpose of this wiki is to rigorously describe Wolfram Language to assist authors of WL tools and students of programming languages. It is not intended as user documentation or a programming tutorial. We invite contributions from anyone. Please read the [[Style Guide]] first. A good place to start is the catch-all page for [[To-Do's and homeless content|Homeless content]]. Table of Contents \u00b6 Language Specification [[Syntax]] [[Primitives]] [[Strings]] [[Number representations]] [[Symbols]] (identifiers) [[Special character representations]] [[Operators]] [[Variadic forms]] [[Operators with a built-in meaning]] List of all operators with precedence, associativity, affix, and arity [[Two-dimensional \"operators\"|Two-dimensional operators]] [[FullForm]] (S-expressions) [[Pseudo-operators]] [[Formatting and whitespace]] [[Box sublanguage]] [[Issues and inconsistencies]] [[Precedence]] [[FullForm interpretation]] [[Nonexpression objects]] (\"atomic functions\") [[Bugs]] [[Semantics]] [[Symbol properties]] [[OwnValues]] [[DownValues, UpValues]] [[DefaultValues]] [[Options]] [[Attributes]] [[Messages]] [[SubValues]] [[NValues]] [[FormatValues]] [[Scoping rules]] [[Scoping operators]] [[Contexts]] [[\u03bb calculus semantics]] [[Packages]] [[Pattern matching]] [[Patterns]] [[Types of equality]] [[Options]] [[Evaluation]] [[Types]] [[Number literal semantics]] [[Messages]] [[Homoiconicity]] [[Built-in Functions / Standard Library|Standard Library]] [[Manipulating primitives and expressions]] [[\"List\" processing and functional programming|List processing]] [[Homoiconic functions]] [[Introspection]] [[Strings]] [[Numbers]] [[Control flow]] [[Controlling evaluation]] [[IO]] [[Mathematics]] [[Graphics]] [[UI]] [[Typesetting]] [[System and Environment]] [[Autoevaluating symbols]] [[Interfaces]] [[Notebook]] [[REPL]] [[Applications]] [[WSTP]] [[WXF]] [[Resources for implementors]] [[General advice for implementors]] [[Test suite derived from this wiki]] [[Implementing pattern matching]] [[Python]] [[Go]] [[ML-like languages]] [[Parsing strategies]] [[Functional language implementation]] [[WL code highlighters and editors]] Repository Notes \u00b6 A Note on Terminology \u00b6 In this wiki and related resources, a W Language is a language with the syntax of Wolfram Language , the programming language of Mathematica . Thus, Wolfram Language is itself a W Language. Some authors of [[WL tools or implementations|List of W Language Projects]] explicitly describe their projects as targeting Mathematica's Wolfram Language, while other authors choose to call their language by a different name. A language implementation and the abstract concept of the language is a blurry distinction. The phrase W Language \u2014WL for short\u2014is intended to be inclusive of all Wolfram Language implementations out of respect for each author's chosen epithet, while Wolfram Language refers to the programming language in the abstract, and Mathematica refers to the software sold by Wolfram which implements Wolfram Language. Why two repositories? \u00b6 The LanguageSpec.wiki repository contains documentation only: Human readable documents. Images or other files displayed within those documents. The LanguageSpec repository contains: Raw data. Example code extracted from this wiki. Tools used to extract example code, create language data, or investigate Mathematica's behavior for the purposes of understanding Wolfram Language. Having two repos provides the following advantages: The wiki is both editable on the web and is a standard git repository compatible with the usual git workflow. Separating the data and tools from the documentation supports the use cases that a user can clone/download one without the other, which we would expect to be a common use case.","title":"Index"},{"location":"Specification/#language-specification","text":"Original home: https://github.com/WLTools/LanguageSpec.git The purpose of this wiki is to rigorously describe Wolfram Language to assist authors of WL tools and students of programming languages. It is not intended as user documentation or a programming tutorial. We invite contributions from anyone. Please read the [[Style Guide]] first. A good place to start is the catch-all page for [[To-Do's and homeless content|Homeless content]].","title":"Language Specification"},{"location":"Specification/#table-of-contents","text":"Language Specification [[Syntax]] [[Primitives]] [[Strings]] [[Number representations]] [[Symbols]] (identifiers) [[Special character representations]] [[Operators]] [[Variadic forms]] [[Operators with a built-in meaning]] List of all operators with precedence, associativity, affix, and arity [[Two-dimensional \"operators\"|Two-dimensional operators]] [[FullForm]] (S-expressions) [[Pseudo-operators]] [[Formatting and whitespace]] [[Box sublanguage]] [[Issues and inconsistencies]] [[Precedence]] [[FullForm interpretation]] [[Nonexpression objects]] (\"atomic functions\") [[Bugs]] [[Semantics]] [[Symbol properties]] [[OwnValues]] [[DownValues, UpValues]] [[DefaultValues]] [[Options]] [[Attributes]] [[Messages]] [[SubValues]] [[NValues]] [[FormatValues]] [[Scoping rules]] [[Scoping operators]] [[Contexts]] [[\u03bb calculus semantics]] [[Packages]] [[Pattern matching]] [[Patterns]] [[Types of equality]] [[Options]] [[Evaluation]] [[Types]] [[Number literal semantics]] [[Messages]] [[Homoiconicity]] [[Built-in Functions / Standard Library|Standard Library]] [[Manipulating primitives and expressions]] [[\"List\" processing and functional programming|List processing]] [[Homoiconic functions]] [[Introspection]] [[Strings]] [[Numbers]] [[Control flow]] [[Controlling evaluation]] [[IO]] [[Mathematics]] [[Graphics]] [[UI]] [[Typesetting]] [[System and Environment]] [[Autoevaluating symbols]] [[Interfaces]] [[Notebook]] [[REPL]] [[Applications]] [[WSTP]] [[WXF]] [[Resources for implementors]] [[General advice for implementors]] [[Test suite derived from this wiki]] [[Implementing pattern matching]] [[Python]] [[Go]] [[ML-like languages]] [[Parsing strategies]] [[Functional language implementation]] [[WL code highlighters and editors]]","title":"Table of Contents"},{"location":"Specification/#repository-notes","text":"","title":"Repository Notes"},{"location":"Specification/#a-note-on-terminology","text":"In this wiki and related resources, a W Language is a language with the syntax of Wolfram Language , the programming language of Mathematica . Thus, Wolfram Language is itself a W Language. Some authors of [[WL tools or implementations|List of W Language Projects]] explicitly describe their projects as targeting Mathematica's Wolfram Language, while other authors choose to call their language by a different name. A language implementation and the abstract concept of the language is a blurry distinction. The phrase W Language \u2014WL for short\u2014is intended to be inclusive of all Wolfram Language implementations out of respect for each author's chosen epithet, while Wolfram Language refers to the programming language in the abstract, and Mathematica refers to the software sold by Wolfram which implements Wolfram Language.","title":"A Note on Terminology"},{"location":"Specification/#why-two-repositories","text":"The LanguageSpec.wiki repository contains documentation only: Human readable documents. Images or other files displayed within those documents. The LanguageSpec repository contains: Raw data. Example code extracted from this wiki. Tools used to extract example code, create language data, or investigate Mathematica's behavior for the purposes of understanding Wolfram Language. Having two repos provides the following advantages: The wiki is both editable on the web and is a standard git repository compatible with the usual git workflow. Separating the data and tools from the documentation supports the use cases that a user can clone/download one without the other, which we would expect to be a common use case.","title":"Why two repositories?"},{"location":"Specification/Interfaces/","text":"Interfaces \u00b6 This is what still needs documenting. Want to help ? Specification Coverage Notebook REPL Applications WSTP WXF","title":"Index"},{"location":"Specification/Interfaces/#interfaces","text":"This is what still needs documenting. Want to help ? Specification Coverage Notebook REPL Applications WSTP WXF","title":"Interfaces"},{"location":"Specification/Interfaces/tasks/","text":"- [ ] Notebook - [ ] REPL - [ ] Applications - [ ] WSTP - [ ] WXF","title":"Tasks"},{"location":"Specification/Semantics/","text":"Semantics of the Wolfram Language \u00b6 This is what still needs documenting. Want to help ? Specification Coverage Symbol properties OwnValues DownValues, UpValues DefaultValues Options Attributes Messages SubValues NValues FormatValues Scoping rules Scoping operators Contexts \u03bb calculus semantics Packages Pattern matching Patterns Types of equality Options Evaluation Types Number literal semantics Messages Homoiconicity","title":"Index"},{"location":"Specification/Semantics/#semantics-of-the-wolfram-language","text":"This is what still needs documenting. Want to help ? Specification Coverage Symbol properties OwnValues DownValues, UpValues DefaultValues Options Attributes Messages SubValues NValues FormatValues Scoping rules Scoping operators Contexts \u03bb calculus semantics Packages Pattern matching Patterns Types of equality Options Evaluation Types Number literal semantics Messages Homoiconicity","title":"Semantics of the Wolfram Language"},{"location":"Specification/Semantics/Number-literal-semantics/","text":"Number Literal Semantics \u00b6 This section describes the meaning of number literal forms, as distinct from their syntax . Approximate Numbers ( Real ) \u00b6 When a Number Literal is Real \u00b6 A number literal representation will be interpreted as a real number if and only if any of the following are true: There is a point . in the mantissa, as in 3.2 . The precision pseudo-operator ` appears in the number literal, regardless of whether or not a numerical precision is given. The accuracy pseudo-operator `` appears in the number literal. Note that a real number cannot be produced by virtue of the use of the scientific form pseudo-operator *^ . See Scientific Form below. Precision and Accuracy \u00b6 A Real number is not a real number in the mathematical sense. Rather, a Real number is what is called a floating point number in other languages. The precision and accuracy of a Real number are functionally equivalent notions that can be understood as follows. Suppose \\(x\\) is a Real number which represents a real number \\(\\hat{x}\\in\\mathbb{R}\\) up to an error of \\(\\delta_x\\) , that is, the true value \\(\\hat{x}\\) of the number represented by \\(x\\) lies in the interval \\((x - \\delta_x/2, x + \\delta_x/2)\\) . If a Real number \\(x\\) has \\(p\\) digits in base \\(b\\) of precision , then \\(\\delta_x = |x|b^{-p}\\) . Likewise, if a Real number \\(x\\) has accuracy \\(a\\) in base \\(b\\) , then \\(\\delta_x = b^{-a}\\) . It is clear from the above that precision depends on the magnitude of the number \\(x\\) , while accuracy does not. Indeed, we have \\(p = a + \\log_{b}|x|\\) . If the precision (or accuracy) of a number literal given with explicit base \\(b\\) is provided, then that precision (repectively accuracy) is interpreted to be the number of digits in the given base \\(b\\) of precision (respectively accuracy). A number written without an explicit base has base \\(10\\) . Therefore, whenever a number literal is written without ^^ , the exponent represents decimal digits of precision/accuracy, that is, the number of digits in base \\(10\\) . Tip The number of digits of precision/accuracy in base \\(10\\) is only approximate in general on a digital computer. This is why most other numerical computing systems only use base 2 corresponding to bits of precision/accuracy. If we desire \\(b\\) bits of accuracy, then we need \\(b/\\log_2(10)\\) decimal digits of accuracy. Said another way, every decimal digit of accuracy requires \\(\\log_2(10) \\approx 3.32193\\) bits of accuracy. Compatibility Warning Syntactically, only undecorated decimal numbers can follow the *^ pseudo-operator, which is inconvenient if one wishes to represent a number in base \\(10\\) (or other nonbinary bases) having a precise number of bits of precision/accuracy. A number decorated with the precision pseudo-operator ` that is not immediately followed by an explicit precision is interpreted as having $MachinePrecision , regardless of whether or not a point . appears in the mantissa, and regardless of how many digits are given explicitly in the number's representation. Info Mathematica defines a $MachinePrecision Real number as a double precision floating point number (\"double\") as defined by the host platform. On systems with 64-bit IEEE doubles, the IEEE standard reserves 53 bits to the mantissa, which is 53 bits of accuracy or about 15.9546 decimal digits of accuracy. Scientific Form \u00b6 The pseudo-operator *^ multiplies the given digits by a power of the base. For a number literal of the form b ^^ m *^ p with base b , mantissa m , and power p (which must be an integer), *^ p has the effect of multiplying b ^^ m by b ^ p ( b raised to the p power). If an explicit base is not given using ^^ , then the base is \\(10\\) and *^ p has the effect of multiplying the number by 10 ^ p . The type of the number literal is determined according to the following rules: If the number would be an Integer without the exponent *^ p , then the number with the exponent *^ p is either an Integer or a Rational according to whether the number is divisible by b ^ p . If the number would be a Real number without the exponent *^ p , then the number with the exponent is a Real number. The pseudo-operator *^ has no effect on the accuracy of a number literal.","title":"Number Literals"},{"location":"Specification/Semantics/Number-literal-semantics/#number-literal-semantics","text":"This section describes the meaning of number literal forms, as distinct from their syntax .","title":"Number Literal Semantics"},{"location":"Specification/Semantics/Number-literal-semantics/#approximate-numbers-real","text":"","title":"Approximate Numbers (Real)"},{"location":"Specification/Semantics/Number-literal-semantics/#when-a-number-literal-isreal","text":"A number literal representation will be interpreted as a real number if and only if any of the following are true: There is a point . in the mantissa, as in 3.2 . The precision pseudo-operator ` appears in the number literal, regardless of whether or not a numerical precision is given. The accuracy pseudo-operator `` appears in the number literal. Note that a real number cannot be produced by virtue of the use of the scientific form pseudo-operator *^ . See Scientific Form below.","title":"When a Number Literal isReal"},{"location":"Specification/Semantics/Number-literal-semantics/#precision-and-accuracy","text":"A Real number is not a real number in the mathematical sense. Rather, a Real number is what is called a floating point number in other languages. The precision and accuracy of a Real number are functionally equivalent notions that can be understood as follows. Suppose \\(x\\) is a Real number which represents a real number \\(\\hat{x}\\in\\mathbb{R}\\) up to an error of \\(\\delta_x\\) , that is, the true value \\(\\hat{x}\\) of the number represented by \\(x\\) lies in the interval \\((x - \\delta_x/2, x + \\delta_x/2)\\) . If a Real number \\(x\\) has \\(p\\) digits in base \\(b\\) of precision , then \\(\\delta_x = |x|b^{-p}\\) . Likewise, if a Real number \\(x\\) has accuracy \\(a\\) in base \\(b\\) , then \\(\\delta_x = b^{-a}\\) . It is clear from the above that precision depends on the magnitude of the number \\(x\\) , while accuracy does not. Indeed, we have \\(p = a + \\log_{b}|x|\\) . If the precision (or accuracy) of a number literal given with explicit base \\(b\\) is provided, then that precision (repectively accuracy) is interpreted to be the number of digits in the given base \\(b\\) of precision (respectively accuracy). A number written without an explicit base has base \\(10\\) . Therefore, whenever a number literal is written without ^^ , the exponent represents decimal digits of precision/accuracy, that is, the number of digits in base \\(10\\) . Tip The number of digits of precision/accuracy in base \\(10\\) is only approximate in general on a digital computer. This is why most other numerical computing systems only use base 2 corresponding to bits of precision/accuracy. If we desire \\(b\\) bits of accuracy, then we need \\(b/\\log_2(10)\\) decimal digits of accuracy. Said another way, every decimal digit of accuracy requires \\(\\log_2(10) \\approx 3.32193\\) bits of accuracy. Compatibility Warning Syntactically, only undecorated decimal numbers can follow the *^ pseudo-operator, which is inconvenient if one wishes to represent a number in base \\(10\\) (or other nonbinary bases) having a precise number of bits of precision/accuracy. A number decorated with the precision pseudo-operator ` that is not immediately followed by an explicit precision is interpreted as having $MachinePrecision , regardless of whether or not a point . appears in the mantissa, and regardless of how many digits are given explicitly in the number's representation. Info Mathematica defines a $MachinePrecision Real number as a double precision floating point number (\"double\") as defined by the host platform. On systems with 64-bit IEEE doubles, the IEEE standard reserves 53 bits to the mantissa, which is 53 bits of accuracy or about 15.9546 decimal digits of accuracy.","title":"Precision and Accuracy"},{"location":"Specification/Semantics/Number-literal-semantics/#scientific-form","text":"The pseudo-operator *^ multiplies the given digits by a power of the base. For a number literal of the form b ^^ m *^ p with base b , mantissa m , and power p (which must be an integer), *^ p has the effect of multiplying b ^^ m by b ^ p ( b raised to the p power). If an explicit base is not given using ^^ , then the base is \\(10\\) and *^ p has the effect of multiplying the number by 10 ^ p . The type of the number literal is determined according to the following rules: If the number would be an Integer without the exponent *^ p , then the number with the exponent *^ p is either an Integer or a Rational according to whether the number is divisible by b ^ p . If the number would be a Real number without the exponent *^ p , then the number with the exponent is a Real number. The pseudo-operator *^ has no effect on the accuracy of a number literal.","title":"Scientific Form"},{"location":"Specification/Semantics/tasks/","text":"- [ ] Symbol properties - [ ] OwnValues - [ ] DownValues, UpValues - [ ] DefaultValues - [ ] Options - [ ] Attributes - [ ] Messages - [ ] SubValues - [ ] NValues - [ ] FormatValues - [ ] Scoping rules - [ ] Scoping operators - [ ] Contexts - [ ] &lambda; calculus semantics - [ ] Packages - [ ] Pattern matching - [ ] Patterns - [ ] Types of equality - [ ] Options - [ ] Evaluation - [ ] Types - [x] [Number literal semantics](Number-literal-semantics.md) - [ ] Messages - [ ] Homoiconicity","title":"Tasks"},{"location":"Specification/StandardLibrary/","text":"Standard Library \u00b6 This is what still needs documenting. Want to help ? Specification Coverage Manipulating primitives and expressions \"List\" processing and functional programming Homoiconic functions Introspection Strings Numbers Control flow Controlling evaluation IO Mathematics Graphics UI Typesetting System and Environment Autoevaluating symbols","title":"Index"},{"location":"Specification/StandardLibrary/#standard-library","text":"This is what still needs documenting. Want to help ? Specification Coverage Manipulating primitives and expressions \"List\" processing and functional programming Homoiconic functions Introspection Strings Numbers Control flow Controlling evaluation IO Mathematics Graphics UI Typesetting System and Environment Autoevaluating symbols","title":"Standard Library"},{"location":"Specification/StandardLibrary/tasks/","text":"- [ ] Manipulating primitives and expressions - [ ] \"List\" processing and functional programming - [ ] Homoiconic functions - [ ] Introspection - [ ] Strings - [ ] Numbers - [ ] Control flow - [ ] Controlling evaluation - [ ] IO - [ ] Mathematics - [ ] Graphics - [ ] UI - [ ] Typesetting - [ ] System and Environment - [ ] Autoevaluating symbols","title":"Tasks"},{"location":"Specification/Syntax/","text":"Syntax of the Wolfram Language \u00b6 This is what still needs documenting. Want to help ? Specification Coverage Primitives Strings Number representations Symbols (identifiers) Special character representations Operators Variadic forms Operators with a built-in meaning List of all operators with precedence, associativity, affix, and arity Two-dimensional \"operators\" FullForm (M-expressions) Pseudo-operators Formatting and whitespace Box sublanguage Issues and inconsistencies Precedence FullForm interpretation Nonexpression objects (\"atomic functions\") Bugs","title":"Index"},{"location":"Specification/Syntax/#syntax-of-the-wolfram-language","text":"This is what still needs documenting. Want to help ? Specification Coverage Primitives Strings Number representations Symbols (identifiers) Special character representations Operators Variadic forms Operators with a built-in meaning List of all operators with precedence, associativity, affix, and arity Two-dimensional \"operators\" FullForm (M-expressions) Pseudo-operators Formatting and whitespace Box sublanguage Issues and inconsistencies Precedence FullForm interpretation Nonexpression objects (\"atomic functions\") Bugs","title":"Syntax of the Wolfram Language"},{"location":"Specification/Syntax/Number-representations/","text":"Syntax of Number Representations \u00b6 Wolfram Language has a curiously flexible syntax for number literals. We will build up a grammar for number literals from their constituent syntactic parts. Signs in a Number Literal Digits Numbers in a specified base Examples Non Examples Specifying numeric precision and accuracy. Examples Non Examples Scientific Form / Scientific Notation Examples Non Examples Additional Examples and Non Examples Examples using special character input forms Example due to Richard Fateman Signs in a Number Literal \u00b6 The sign of a number, that is, whether the number is positive, zero, or negative, is manifestly intrinsic to the semantics of the number. However, a number's sign, when given explicitly, is treated syntactically as an operator. Indeed, there are several operators effecting the sign of a number: Minus , UnaryPlus , PlusMinus , and MinusPlus . These operators may even be nested arbitrarily, as in the expression -+ 7 . Thus, treating the negative sign in, say, - 7 as an operator is syntactically the more consistent alternative. As a consequence, all number literals in Wolfram Language are necessarily nonnegative according to this spec. The exception to this rule applies not to number literals but rather to the decorations on number literals: the precision, accuracy, and exponent all accept a single (unnested) optional + or - . Compatibility Warning Mathematica only accepts the ASCII - character and its character code synonyms \\:002d and \\.2d in number literal forms. The Unicode character form \\:2212 , named character \\[Minus] , and corresponding Unicode literal \u2212 (which renders identically to ASCII - ) are not allowed within number literal forms. This spec requires complying implementations to accept the ASCII - in number literal decorations. However, implementations may also accept Unicode Minus anywhere an ASCII - may appear. (There is no Unicode equivalent to + that Mathematica recognizes, so + does not have this issue.) Digits \u00b6 The most basic component of any number is the digit. The decimal digits 0 through 9 are fundamental even within number forms expressed in bases other than 10. fragment DIGIT : [ 0-9 ]; Wherever a number with a point is allowed to appear, either the digits to the left of the point or the right of the point may be ommitted, but not both. Note that numbers may begin with any number of leading zeros. fragment DecimalNumber : DIGIT + '.' DIGIT * // We can omit numbers after the decimal point and not before, or... | DIGIT * '.' DIGIT + // ...before the decimal point and not after. | DIGIT + // An integer, no (decimal) point. ; Note that a negative sign is not included in the definition of DecimalNumber . Numbers in a specified base \u00b6 Wolfram Language also allows number literals in bases other than base 10, with letters 1 acting as the digits for bases higher than 10, up to base 36. 2 No distinction is made between lowercase and capital letters. fragment DigitInAnyBase : DIGIT | [ a-zA-Z ]; fragment NonDecimalNumber : DigitInAnyBase + '.' DigitInAnyBase * // We can omit numbers after the decimal point and not before, or... | DigitInAnyBase * '.' DigitInAnyBase + // ...before the decimal point and not after. | DigitInAnyBase + // An integer, no point. ; fragment NumberInBase : DIGIT + '^^' NonDecimalNumber ; // Additional constraints below. The number preceding the ^^ pseudo-operator specifies the base in which the following digit sequence is to be interpreted. The digit sequence is unsigned, that is, no - is allowed to follow ^^ The NumberInBase production must satisfy the following additional constraints: The ^^ must be preceded by a base that is an integer between \\(2\\) and \\(36\\) , itself expressed in base \\(10\\) , though the base may have arbitrarily many leading zeros. The NonDecimalNumber following ^^ may contain only digits compatible with the base. Thus a number in base \\(n\\) consists of digits corresponding to the decimal numbers \\(0\\) to \\(n -1\\) , and each digit greater than \\(9\\) is represented by a letter according to the following table. 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 a b c d e f g h i j k l m n o p q r s t u v w x y z Examples \u00b6 2^^101.101 (* 5.625 *) 35 ^^ WolframLanguage (* 135376476330464607218449 *) 16 ^^ dead . Beef (* 57005.7 *) Non Examples \u00b6 1^^0.00 (* $Failed *) 3.5 ^^ 12 (* Syntax::sntxf: \"3.5^\" cannot be followed by \"^12\". *) 6^^1972 (* General::digit: Digit at position 2 in 1972 is too large to be used in base 6. *) 99^^123 abc (* $Failed *) 10 ^^- 30 (* Syntax::tsntxi: \"10^^-35\" is incomplete; more input is needed. *) Info The output in the non examples above are those given by Mathematica v11.3.0. Implementations are encouraged to provide more consistently helpful error messages, especially for the last non example. Specifying numeric precision and accuracy. \u00b6 Precision and accuracy are related concepts in Wolfram Language. See the section index.md for a detailed discussion. A number literal may either specify a precision or an accuracy, but not both. A single backtick ` after a number specifies machine precision . A number followed by a single backtick and a DecimalNumber specifies a precision of DecimalNumber . A precision or accuracy specifier must appear before a scientific form multiplier. fragment numberLiteralPrecision : '`' (( '+' | '-' )? DecimalNumber )? // Precision | '``' ( '+' | '-' )? DecimalNumber // Accuracy ; Note that if a sign is given for precision, it must be followed by a DecimalNumber . Warning Mathematica's Precision and Accuracy functions can return \u221e for some inputs. However, \u221e cannot be used in a number literal. Examples \u00b6 123` (* 123. *) 1.381` (* 1.381 *) 16^^9 fe . c3` 7 (* 2558.76172 *) 3.0` + 7 (* 3.000000 *) 3`7 (* 3.000000 *) 3.000000000000000000000`7 (* 3.000000 *) 3.000000000000000000` - 7 (* 0. *) Non Examples \u00b6 16^^9 fe . c3`\\[Minus] 7 (* Treated as subtraction. *) (* 2551.76 *) 3.98` ` (* Syntax::sntxf: \"3.98\" cannot be followed by \"``\". *) 2` `\\ : 22127 (* Differs in command line vs FE vs `ToExpression`. *) (* 2 *) (* Syntax::tsntxi: \"2.\\[Minus]7\" is incomplete; more input is needed. *) 2` `\\[Minus] 7 (* WARNING: Crashes command line interface leaving zombie kernel running at 100% of CPU. *) (* Syntax::tsntxi: \"2.\\[Minus]7\" is incomplete; more input is needed. *) 2` + (* Syntax::tsntxi: \"2.+\" is incomplete; more input is needed. *) 2` - (* Syntax::tsntxi: \"2.-\" is incomplete; more input is needed. *) 3` ` + (* Syntax::sntxf: \"3\" cannot be followed by \"``+\". *) (* Syntax::tsntxi: \"3.+\" is incomplete; more input is needed. *) 3` ` - (* Syntax::sntxf: \"3\" cannot be followed by \"``-\". *) (* Syntax::tsntxi: \"3.-\" is incomplete; more input is needed. *) 2.78`26 `` 10 (* Syntax::tsntxi: \"2.78`26``10\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"2.78`26\" cannot be followed by \"``10\". *) 2.78` ` 26`10 (* Syntax::tsntxi: \"2.78`26`10\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"2.78``26\" cannot be followed by \"`10\". *) 3` \\[Infinity] (* Interpreted as 3.0 * \\[Infinity] *) (* \u221e *) 3` `\\[Infinity] (* WARNING: Crashes command line interface leaving zombie kernel running at 100% of CPU. *) (* $CharacterEncoding::utf8: The byte sequence {249} could not be interpreted as a character in the UTF-8 character encoding. *) Scientific Form / Scientific Notation \u00b6 A multiplier base ^ power may be provided using the pseudo-operator *^ followed by an optionally signed integral power itself expressed in base \\(10\\) . The *^ expression must appear after any precision or accuracy expression. fragment numberLiteralExponent : '*^' ( '+' | '-' )? DIGITS ; Observe that This form does not contain DecimalNumber but rather DIGITS , which is a string of digits in base \\(10\\) . The *^ must be followed by DIGITS . Examples \u00b6 3.98`5*^3 (* 3980.0 *) 16 ^^ dead . beef` ` + 4 *^- 3 (* 13.9174 *) 0.0000000001*^10 (* 1. *) 35 ^^ small *^- 10 // InputForm (* 6139108/394078193359375 *) 10000000000 *^- 10 (* 1 *) Non Examples \u00b6 1.0*^1.9 (* Parsed by FE as (1.0*^1)*0.9. *) (* General::ifexp: The exponent 1.9 is not an integer. Syntax::sntxb: Expression cannot begin with \"1.0*^1.9\". *) 3 *^ \\[Minus] 1 (* FE message vs. command line message. *) (* Syntax::tsntxi: \"3.^\\[Minus]1\" is incomplete; more input is needed. *) (* Syntax::sntxb: Expression cannot begin with \"3*^\\[Minus]1\". *) 3.98*^3 ` 5 (* FE message vs. command line message. *) (* Syntax::tsntxi: \"3.98*10^3`5\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"3.98*^3\" cannot be followed by \"`5\". *) 16 ^^ dead . beef *^- 3` ` 4 (* FE message vs. command line message. *) (* Syntax::tsntxi: \"16^^dead.beef*^-3``4\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"16^^dead.beef*^-3\" cannot be followed by \"``4\". *) 1 *^ \\[Infinity] (* FE message vs. command line message. *) (* Syntax::sntxb: Expression cannot begin with \"1*^\\[Infinity]\". *) (* Syntax::tsntxi: \"1.^\\[Infinity]\" is incomplete; more input is needed. *) Complete Number Representation \u00b6 We combine the grammar components defined above to obtain the final grammar production for number literals. numberLiteral : DIGITS NumberInBase numberLiteralPrecision ? numberLiteralExponent ? // Number in any base. | ( DIGITS | DecimalNumber ) numberLiteralPrecision ? numberLiteralExponent ? // Number in base ten. ; Compatibility Warning Mathematica automatically interprets number literals, discarding the original input form in most cases. Consequently, there is no FullForm representation of number literals. One cannot extract, for example, the base of a number. Implementations may emulate Mathematica's behavior or maintain the input representation of a number literal. Compatibility Warning Mathematica does not allow any whitespace whatsoever within a number literal expression. A Regular Expression Accepting Number Literals \u00b6 The following regular expression matches all Wolfram Language number literals without special character input forms. However, if a base is specified, it does not require that the given digits are compatible with the base, but those are the only invalid strings it accepts. ((([ 2 - 9 ] | [ 1 - 2 ] \\ d | [ 3 ][ 0 - 5 ]) \\^\\^ ( \\ w *\\.\\ w +|\\ w +\\.\\ w *|\\ w + )) | ( \\ d *\\.\\ d +|\\ d +\\.\\ d *|\\ d + ))(( `` ( \\+|- )?( \\ d *\\.\\ d +|\\ d +\\.\\ d *|\\ d + )) | ( ` (( \\+|- )?( \\ d *\\.\\ d +|\\ d +\\.\\ d *|\\ d + ))?))?( \\*\\^ ( \\+|- )? \\ d + )? Important This regular expression does not require that the digits be compatible with the given base. For example, it will match 7^^2 a even though a is not a digit in base \\(7\\) . However, it does match only bases between \\(2\\) and \\(36\\) . Additional Examples and Non Examples \u00b6 Examples using special character input forms \u00b6 4 \\ .2 b5 (* ASCII plus is 0x2B. *) (* 9 *) 4 \\ : 002 b5 (* 9 *) 4 \\ .2 d6 (* ASCII minus is 0x2D. *) (* -2 *) 4 \\ : 002 d6 (* -2 *) 4 *^ \\ .2 b01 (* 40 *) 4 *^ \\ : 002 b01 (* 40 *) 4` `\\ .2 b02 (* 4.0 *) 4` `\\ .2 b02 (* 4.0 *) 4` \\ .2 b02 (* 4.0 *) 4` \\ .2 b02 (* 4.0 *) \\ .31 \\ .36 \\ .5 e \\ .5 e \\ .44 \\ .65 \\ .61 \\ .64 \\ .2 e \\ .42 \\ .65 \\ .65 \\ .66 \\ .60 \\ .60 \\ .2 b \\ .34 \\ .2 a ^- 3 (* 16^^Dead.Beef``+4*^-3 *) (* 13.9174 *) \\ : 0031 \\ : 0036 \\ : 005 e \\ : 005 e \\ : 0044 \\ : 0065 \\ : 0061 \\ : 0064 \\ : 002 e \\ : 0042 \\ : 0065 \\ : 0065 \\ : 0066 \\ : 0060 \\ : 0060 \\ : 002 b \\ : 0034 \\ : 002 a \\ : 005 e \\ : 002 d \\ : 0033 (* 16^^Dead.Beef``+4*^-3 *) (* 13.9174 *) 16 ^^ \\ .66 (* 15 *) Example due to Richard Fateman \u00b6 This example is from: Richard J. Fateman, \"A review of Mathematica,\" Journal of Symbolic Computation, vol. 13, iss. 5, May 1992, p. 554. doi: 10.1016/s0747-7171(10)80011-2 4 /. 4 -> 5 (* 10. -> 5 *) 4 / .4 -> 5 (* 10. -> 5 *) 4 /. 4 -> 5 (* 10. -> 5 *) 4 /. 4 -> 5 (* 5 *) Here we mean letters in the ISO basic Latin alphabet , not to be confused with the letter-like forms of Mathematica. \u21a9 The limitation to a maximum base of 36 is, of course, due to the fact that there are only 10 decimal digits and 26 letters, making 36 different possible digits to use in a number literal. An implementation could conceivably allow larger integral bases despite an inability to express every digit in the base, e.g., 100^^25 == 205 . Such number forms would be confusing, to say the least, and so are disallowed by this spec. \u21a9","title":"Number Representations"},{"location":"Specification/Syntax/Number-representations/#syntax-of-number-representations","text":"Wolfram Language has a curiously flexible syntax for number literals. We will build up a grammar for number literals from their constituent syntactic parts. Signs in a Number Literal Digits Numbers in a specified base Examples Non Examples Specifying numeric precision and accuracy. Examples Non Examples Scientific Form / Scientific Notation Examples Non Examples Additional Examples and Non Examples Examples using special character input forms Example due to Richard Fateman","title":"Syntax of Number Representations"},{"location":"Specification/Syntax/Number-representations/#signs-in-a-number-literal","text":"The sign of a number, that is, whether the number is positive, zero, or negative, is manifestly intrinsic to the semantics of the number. However, a number's sign, when given explicitly, is treated syntactically as an operator. Indeed, there are several operators effecting the sign of a number: Minus , UnaryPlus , PlusMinus , and MinusPlus . These operators may even be nested arbitrarily, as in the expression -+ 7 . Thus, treating the negative sign in, say, - 7 as an operator is syntactically the more consistent alternative. As a consequence, all number literals in Wolfram Language are necessarily nonnegative according to this spec. The exception to this rule applies not to number literals but rather to the decorations on number literals: the precision, accuracy, and exponent all accept a single (unnested) optional + or - . Compatibility Warning Mathematica only accepts the ASCII - character and its character code synonyms \\:002d and \\.2d in number literal forms. The Unicode character form \\:2212 , named character \\[Minus] , and corresponding Unicode literal \u2212 (which renders identically to ASCII - ) are not allowed within number literal forms. This spec requires complying implementations to accept the ASCII - in number literal decorations. However, implementations may also accept Unicode Minus anywhere an ASCII - may appear. (There is no Unicode equivalent to + that Mathematica recognizes, so + does not have this issue.)","title":"Signs in a Number Literal"},{"location":"Specification/Syntax/Number-representations/#digits","text":"The most basic component of any number is the digit. The decimal digits 0 through 9 are fundamental even within number forms expressed in bases other than 10. fragment DIGIT : [ 0-9 ]; Wherever a number with a point is allowed to appear, either the digits to the left of the point or the right of the point may be ommitted, but not both. Note that numbers may begin with any number of leading zeros. fragment DecimalNumber : DIGIT + '.' DIGIT * // We can omit numbers after the decimal point and not before, or... | DIGIT * '.' DIGIT + // ...before the decimal point and not after. | DIGIT + // An integer, no (decimal) point. ; Note that a negative sign is not included in the definition of DecimalNumber .","title":"Digits"},{"location":"Specification/Syntax/Number-representations/#numbers-in-a-specified-base","text":"Wolfram Language also allows number literals in bases other than base 10, with letters 1 acting as the digits for bases higher than 10, up to base 36. 2 No distinction is made between lowercase and capital letters. fragment DigitInAnyBase : DIGIT | [ a-zA-Z ]; fragment NonDecimalNumber : DigitInAnyBase + '.' DigitInAnyBase * // We can omit numbers after the decimal point and not before, or... | DigitInAnyBase * '.' DigitInAnyBase + // ...before the decimal point and not after. | DigitInAnyBase + // An integer, no point. ; fragment NumberInBase : DIGIT + '^^' NonDecimalNumber ; // Additional constraints below. The number preceding the ^^ pseudo-operator specifies the base in which the following digit sequence is to be interpreted. The digit sequence is unsigned, that is, no - is allowed to follow ^^ The NumberInBase production must satisfy the following additional constraints: The ^^ must be preceded by a base that is an integer between \\(2\\) and \\(36\\) , itself expressed in base \\(10\\) , though the base may have arbitrarily many leading zeros. The NonDecimalNumber following ^^ may contain only digits compatible with the base. Thus a number in base \\(n\\) consists of digits corresponding to the decimal numbers \\(0\\) to \\(n -1\\) , and each digit greater than \\(9\\) is represented by a letter according to the following table. 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 \u2195 a b c d e f g h i j k l m n o p q r s t u v w x y z","title":"Numbers in a specified base"},{"location":"Specification/Syntax/Number-representations/#examples","text":"2^^101.101 (* 5.625 *) 35 ^^ WolframLanguage (* 135376476330464607218449 *) 16 ^^ dead . Beef (* 57005.7 *)","title":"Examples"},{"location":"Specification/Syntax/Number-representations/#non-examples","text":"1^^0.00 (* $Failed *) 3.5 ^^ 12 (* Syntax::sntxf: \"3.5^\" cannot be followed by \"^12\". *) 6^^1972 (* General::digit: Digit at position 2 in 1972 is too large to be used in base 6. *) 99^^123 abc (* $Failed *) 10 ^^- 30 (* Syntax::tsntxi: \"10^^-35\" is incomplete; more input is needed. *) Info The output in the non examples above are those given by Mathematica v11.3.0. Implementations are encouraged to provide more consistently helpful error messages, especially for the last non example.","title":"Non Examples"},{"location":"Specification/Syntax/Number-representations/#specifying-numeric-precision-and-accuracy","text":"Precision and accuracy are related concepts in Wolfram Language. See the section index.md for a detailed discussion. A number literal may either specify a precision or an accuracy, but not both. A single backtick ` after a number specifies machine precision . A number followed by a single backtick and a DecimalNumber specifies a precision of DecimalNumber . A precision or accuracy specifier must appear before a scientific form multiplier. fragment numberLiteralPrecision : '`' (( '+' | '-' )? DecimalNumber )? // Precision | '``' ( '+' | '-' )? DecimalNumber // Accuracy ; Note that if a sign is given for precision, it must be followed by a DecimalNumber . Warning Mathematica's Precision and Accuracy functions can return \u221e for some inputs. However, \u221e cannot be used in a number literal.","title":"Specifying numeric precision and accuracy."},{"location":"Specification/Syntax/Number-representations/#examples_1","text":"123` (* 123. *) 1.381` (* 1.381 *) 16^^9 fe . c3` 7 (* 2558.76172 *) 3.0` + 7 (* 3.000000 *) 3`7 (* 3.000000 *) 3.000000000000000000000`7 (* 3.000000 *) 3.000000000000000000` - 7 (* 0. *)","title":"Examples"},{"location":"Specification/Syntax/Number-representations/#non-examples_1","text":"16^^9 fe . c3`\\[Minus] 7 (* Treated as subtraction. *) (* 2551.76 *) 3.98` ` (* Syntax::sntxf: \"3.98\" cannot be followed by \"``\". *) 2` `\\ : 22127 (* Differs in command line vs FE vs `ToExpression`. *) (* 2 *) (* Syntax::tsntxi: \"2.\\[Minus]7\" is incomplete; more input is needed. *) 2` `\\[Minus] 7 (* WARNING: Crashes command line interface leaving zombie kernel running at 100% of CPU. *) (* Syntax::tsntxi: \"2.\\[Minus]7\" is incomplete; more input is needed. *) 2` + (* Syntax::tsntxi: \"2.+\" is incomplete; more input is needed. *) 2` - (* Syntax::tsntxi: \"2.-\" is incomplete; more input is needed. *) 3` ` + (* Syntax::sntxf: \"3\" cannot be followed by \"``+\". *) (* Syntax::tsntxi: \"3.+\" is incomplete; more input is needed. *) 3` ` - (* Syntax::sntxf: \"3\" cannot be followed by \"``-\". *) (* Syntax::tsntxi: \"3.-\" is incomplete; more input is needed. *) 2.78`26 `` 10 (* Syntax::tsntxi: \"2.78`26``10\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"2.78`26\" cannot be followed by \"``10\". *) 2.78` ` 26`10 (* Syntax::tsntxi: \"2.78`26`10\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"2.78``26\" cannot be followed by \"`10\". *) 3` \\[Infinity] (* Interpreted as 3.0 * \\[Infinity] *) (* \u221e *) 3` `\\[Infinity] (* WARNING: Crashes command line interface leaving zombie kernel running at 100% of CPU. *) (* $CharacterEncoding::utf8: The byte sequence {249} could not be interpreted as a character in the UTF-8 character encoding. *)","title":"Non Examples"},{"location":"Specification/Syntax/Number-representations/#scientific-form-scientific-notation","text":"A multiplier base ^ power may be provided using the pseudo-operator *^ followed by an optionally signed integral power itself expressed in base \\(10\\) . The *^ expression must appear after any precision or accuracy expression. fragment numberLiteralExponent : '*^' ( '+' | '-' )? DIGITS ; Observe that This form does not contain DecimalNumber but rather DIGITS , which is a string of digits in base \\(10\\) . The *^ must be followed by DIGITS .","title":"Scientific Form / Scientific Notation"},{"location":"Specification/Syntax/Number-representations/#examples_2","text":"3.98`5*^3 (* 3980.0 *) 16 ^^ dead . beef` ` + 4 *^- 3 (* 13.9174 *) 0.0000000001*^10 (* 1. *) 35 ^^ small *^- 10 // InputForm (* 6139108/394078193359375 *) 10000000000 *^- 10 (* 1 *)","title":"Examples"},{"location":"Specification/Syntax/Number-representations/#non-examples_2","text":"1.0*^1.9 (* Parsed by FE as (1.0*^1)*0.9. *) (* General::ifexp: The exponent 1.9 is not an integer. Syntax::sntxb: Expression cannot begin with \"1.0*^1.9\". *) 3 *^ \\[Minus] 1 (* FE message vs. command line message. *) (* Syntax::tsntxi: \"3.^\\[Minus]1\" is incomplete; more input is needed. *) (* Syntax::sntxb: Expression cannot begin with \"3*^\\[Minus]1\". *) 3.98*^3 ` 5 (* FE message vs. command line message. *) (* Syntax::tsntxi: \"3.98*10^3`5\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"3.98*^3\" cannot be followed by \"`5\". *) 16 ^^ dead . beef *^- 3` ` 4 (* FE message vs. command line message. *) (* Syntax::tsntxi: \"16^^dead.beef*^-3``4\" is incomplete; more input is needed. *) (* Syntax::sntxf: \"16^^dead.beef*^-3\" cannot be followed by \"``4\". *) 1 *^ \\[Infinity] (* FE message vs. command line message. *) (* Syntax::sntxb: Expression cannot begin with \"1*^\\[Infinity]\". *) (* Syntax::tsntxi: \"1.^\\[Infinity]\" is incomplete; more input is needed. *)","title":"Non Examples"},{"location":"Specification/Syntax/Number-representations/#complete-number-representation","text":"We combine the grammar components defined above to obtain the final grammar production for number literals. numberLiteral : DIGITS NumberInBase numberLiteralPrecision ? numberLiteralExponent ? // Number in any base. | ( DIGITS | DecimalNumber ) numberLiteralPrecision ? numberLiteralExponent ? // Number in base ten. ; Compatibility Warning Mathematica automatically interprets number literals, discarding the original input form in most cases. Consequently, there is no FullForm representation of number literals. One cannot extract, for example, the base of a number. Implementations may emulate Mathematica's behavior or maintain the input representation of a number literal. Compatibility Warning Mathematica does not allow any whitespace whatsoever within a number literal expression.","title":"Complete Number Representation"},{"location":"Specification/Syntax/Number-representations/#a-regular-expression-accepting-number-literals","text":"The following regular expression matches all Wolfram Language number literals without special character input forms. However, if a base is specified, it does not require that the given digits are compatible with the base, but those are the only invalid strings it accepts. ((([ 2 - 9 ] | [ 1 - 2 ] \\ d | [ 3 ][ 0 - 5 ]) \\^\\^ ( \\ w *\\.\\ w +|\\ w +\\.\\ w *|\\ w + )) | ( \\ d *\\.\\ d +|\\ d +\\.\\ d *|\\ d + ))(( `` ( \\+|- )?( \\ d *\\.\\ d +|\\ d +\\.\\ d *|\\ d + )) | ( ` (( \\+|- )?( \\ d *\\.\\ d +|\\ d +\\.\\ d *|\\ d + ))?))?( \\*\\^ ( \\+|- )? \\ d + )? Important This regular expression does not require that the digits be compatible with the given base. For example, it will match 7^^2 a even though a is not a digit in base \\(7\\) . However, it does match only bases between \\(2\\) and \\(36\\) .","title":"A Regular Expression Accepting Number Literals"},{"location":"Specification/Syntax/Number-representations/#additional-examples-and-non-examples","text":"","title":"Additional Examples and Non Examples"},{"location":"Specification/Syntax/Number-representations/#examples-using-special-character-input-forms","text":"4 \\ .2 b5 (* ASCII plus is 0x2B. *) (* 9 *) 4 \\ : 002 b5 (* 9 *) 4 \\ .2 d6 (* ASCII minus is 0x2D. *) (* -2 *) 4 \\ : 002 d6 (* -2 *) 4 *^ \\ .2 b01 (* 40 *) 4 *^ \\ : 002 b01 (* 40 *) 4` `\\ .2 b02 (* 4.0 *) 4` `\\ .2 b02 (* 4.0 *) 4` \\ .2 b02 (* 4.0 *) 4` \\ .2 b02 (* 4.0 *) \\ .31 \\ .36 \\ .5 e \\ .5 e \\ .44 \\ .65 \\ .61 \\ .64 \\ .2 e \\ .42 \\ .65 \\ .65 \\ .66 \\ .60 \\ .60 \\ .2 b \\ .34 \\ .2 a ^- 3 (* 16^^Dead.Beef``+4*^-3 *) (* 13.9174 *) \\ : 0031 \\ : 0036 \\ : 005 e \\ : 005 e \\ : 0044 \\ : 0065 \\ : 0061 \\ : 0064 \\ : 002 e \\ : 0042 \\ : 0065 \\ : 0065 \\ : 0066 \\ : 0060 \\ : 0060 \\ : 002 b \\ : 0034 \\ : 002 a \\ : 005 e \\ : 002 d \\ : 0033 (* 16^^Dead.Beef``+4*^-3 *) (* 13.9174 *) 16 ^^ \\ .66 (* 15 *)","title":"Examples using special character input forms"},{"location":"Specification/Syntax/Number-representations/#example-due-to-richard-fateman","text":"This example is from: Richard J. Fateman, \"A review of Mathematica,\" Journal of Symbolic Computation, vol. 13, iss. 5, May 1992, p. 554. doi: 10.1016/s0747-7171(10)80011-2 4 /. 4 -> 5 (* 10. -> 5 *) 4 / .4 -> 5 (* 10. -> 5 *) 4 /. 4 -> 5 (* 10. -> 5 *) 4 /. 4 -> 5 (* 5 *) Here we mean letters in the ISO basic Latin alphabet , not to be confused with the letter-like forms of Mathematica. \u21a9 The limitation to a maximum base of 36 is, of course, due to the fact that there are only 10 decimal digits and 26 letters, making 36 different possible digits to use in a number literal. An implementation could conceivably allow larger integral bases despite an inability to express every digit in the base, e.g., 100^^25 == 205 . Such number forms would be confusing, to say the least, and so are disallowed by this spec. \u21a9","title":"Example due to Richard Fateman"},{"location":"Specification/Syntax/OperatorTable/","text":"Table of Wolfram Language Operators \u00b6 Accurate information about all Mathematica operators is notoriously hard to obtain. Mathematica's official documentation is incomplete, out of date, and occassionally incorrect. So is the undocumented Precedence function. 1 Complicating matters is the fact that the frontend does not always agree with the kernel (i.e. the command line interface or ToExpression ) about the properties of an operator, and none of these conflicts are documented. Robert Jacobson has compiled a list of all operators and their properties according to the kernel. 2 This information is available in the following machine and human readable formats: A Microsoft Excel spreadsheet . An html page suitable for browsing online. A CSV file . If you discover an error, please report it by creating an issue on GitHub . For a detailed discussion of these issues, see Robert Jacobson, \" Finding All Wolfram Language Operators ,\" After Math , personal blog, August 16, 2018. \u21a9 He is working on doing the same for the frontend. \u21a9","title":"Operator Table"},{"location":"Specification/Syntax/OperatorTable/#table-of-wolfram-language-operators","text":"Accurate information about all Mathematica operators is notoriously hard to obtain. Mathematica's official documentation is incomplete, out of date, and occassionally incorrect. So is the undocumented Precedence function. 1 Complicating matters is the fact that the frontend does not always agree with the kernel (i.e. the command line interface or ToExpression ) about the properties of an operator, and none of these conflicts are documented. Robert Jacobson has compiled a list of all operators and their properties according to the kernel. 2 This information is available in the following machine and human readable formats: A Microsoft Excel spreadsheet . An html page suitable for browsing online. A CSV file . If you discover an error, please report it by creating an issue on GitHub . For a detailed discussion of these issues, see Robert Jacobson, \" Finding All Wolfram Language Operators ,\" After Math , personal blog, August 16, 2018. \u21a9 He is working on doing the same for the frontend. \u21a9","title":"Table of Wolfram Language Operators"},{"location":"Specification/Syntax/OperatorTableHTML/","text":"&lt;!-- table {table-layout: fixed; }</p> <p>td { padding-top:1px; padding-right:1px; padding-left:1px; color:black; font-size:10.0pt; font-weight:400; font-style:normal; text-decoration:none; font-family:\"Helvetica\"; text-align:general; vertical-align:middle; border:.5pt solid #A5A5A5; white-space: nowrap; } tr { height:20pt; } .hlempty { border:.5pt solid #A5A5A5; background:#FFFC98; } .hlincomp { border:.5pt solid #A5A5A5; background:#FFD38A; } .hlequal { border:.5pt solid #A5A5A5; background:#AFE489; } .hlunequal{ border:.5pt solid #A5A5A5; background:#FF9781; } .heading { font-weight:700; border:.5pt solid #A5A5A5; background:#BDC0BF; white-space:nowrap; } td:nth-child(4), td:nth-child(5), td:nth-child(8), td:nth-child(11) { text-align:right; } td:nth-child(24) { white-space:normal; max-width: 10000pt; } &rarr; Unofficial Name Name Actual Precedence Precedence[ ] Precedence[ ] Corrected WolframLanguageData[ ] WolframLanguageData[ ] Corrected UnicodeCharacters.tr UnicodeCharacters.tr Corrected Usage Parse FullForm N Tokens L Tokens O Tokens Arity Affix Associativity Meaningful Comments AngleBracket = AngleBracket -10 670 760 1 -10 = -10 {{\"\u2329\", \"expr\", \"\u232a\"}} {\"AngleBracket\", \"[\", \"expr\", \",\", \"\u2026\", \"]\"} AngleBracket[expr, \\[Ellipsis]] {\"\u2329\"} {} {\"\u232a\"} n-ary Matchfix Non False Association = Association -10 670 760 1 -10 = -10 {{\"<|\", \"expr\", \"|>\"}, {\"\uf113\", \"expr\", \"\uf114\"}} {\"Association\", \"[\", \"expr\", \",\", \"\u2026\", \"]\"} Association[expr, \\[Ellipsis]] {\"<|\", \"\uf113\"} {} {\"|>\", \"\uf114\"} n-ary Matchfix Non True BracketingBar = BracketingBar -10 670 760 1 -10 = -10 {{\"\uf603\", \"expr\", \"\uf604\"}} {\"BracketingBar\", \"[\", \"expr\", \",\", \"\u2026\", \"]\"} BracketingBar[expr, \\[Ellipsis]] {\"\uf603\"} {} {\"\uf604\"} n-ary Matchfix Non False Ceiling = Ceiling -10 670 760 1 -10 = -10 {{\"\u2308\", \"expr\", \"\u2309\"}} {\"Ceiling\", \"[\", \"expr\", \"]\"} Ceiling[expr] {\"\u2308\"} {} {\"\u2309\"} Unary Matchfix Non True DoubleBracketingBar = DoubleBracketingBar -10 670 760 1 -10 = -10 {{\"\uf605\", \"expr\", \"\uf606\"}} {\"DoubleBracketingBar\", \"[\", \"expr\", \",\", \"\u2026\", \"]\"} DoubleBracketingBar[expr, \\[Ellipsis]] {\"\uf605\"} {} {\"\uf606\"} n-ary Matchfix Non False Floor = Floor -10 670 760 1 -10 = -10 {{\"\u230a\", \"expr\", \"\u230b\"}} {\"Floor\", \"[\", \"expr\", \"]\"} Floor[expr] {\"\u230a\"} {} {\"\u230b\"} Unary Matchfix Non True List = List -10 670 760 1 = 1 -10 {{\"{\", \"expr\", \"}\"}} {\"List\", \"[\", \"expr\", \",\", \"\u2026\", \"]\"} List[expr, \\[Ellipsis]] {\"{\"} {} {\"}\"} n-ary Matchfix Non True AutoMatch = AutoMatch -10 670 760 1 -10 = -10 {{\"\uf3a8\", \"expr\", \"\uf3a9\"}} {\"AutoMatch\",\"[\",\"expr\",\"]\"} AutoMatch[expr] {\"\uf3a8\"} {} {\"\uf3a9\"} Unary Matchfix Non True Skeleton = Skeleton -10 670 760 1 -10 = -10 {{\"\uf761\", \"n\", \"\uf762\"}} {\"Skeleton\",\"[\",\"n\",\"]\"} Skeleton[n] {\"\uf761\"} {} {\"\uf762\"} Unary Matchfix Non True CurlyDoubleQuote = CurlyDoubleQuote -10 670 760 1 -10 = -10 {{\"\u201c\", \"expr\", \"\u201d\"}} {\"CurlyDoubleQuote\",\"[\",\"expr\",\"]\"} CurlyDoubleQuote[expr] {\"\u201c\"} {} {\"\u201d\"} Unary Matchfix Non False CurlyQuote = CurlyQuote -10 670 760 1 -10 = -10 {{\"\u2018\", \"expr\", \"\u2019\"}} {\"CurlyQuote\",\"[\",\"expr\",\"]\"} CurlyQuote[expr] {\"\u2018\"} {} {\"\u2019\"} Unary Matchfix Non False FullwidthParenthesis = FullwidthParenthesis -10 670 760 1 -10 = -10 {{\"\uff08\", \"expr\", \"\uff09\"}} {\"\uff08\"} {} {\"\uff09\"} Unary Matchfix Non True DoubleAngleBracket = DoubleAngleBracket -10 670 760 1 -10 = -10 {{\"\u300a\", \"expr\", \"\u300b\"}} {\"\u300a\"} {} {\"\u300b\"} Unary Matchfix Non True FullwidthAngleBracket = FullwidthAngleBracket -10 670 760 1 -10 = -10 {{\"\u3008\", \"expr\", \"\u3009\"}} {\"\u3008\"} {} {\"\u3009\"} Unary Matchfix Non True FullwidthSquareBracket = FullwidthSquareBracket -10 670 760 1 -10 = -10 {{\"\uff3b\", \"expr\", \"\uff3d\"}} {\"\uff3b\"} {} {\"\uff3d\"} Unary Matchfix Non True TortoiseShellBracket = TortoiseShellBracket -10 670 760 1 -10 = -10 {{\"\u3014\", \"expr\", \"\u3015\"}} {\"\u3014\"} {} {\"\u3015\"} Unary Matchfix Non True BlackLenticularBracket = BlackLenticularBracket -10 670 760 1 -10 = -10 {{\"\u3010\", \"expr\", \"\u3011\"}} {\"\u3010\"} {} {\"\u3011\"} Unary Matchfix Non True WhiteCornerBracket = WhiteCornerBracket -10 670 760 1 -10 = -10 {{\"\u300e\", \"expr\", \"\u300f\"}} {\"\u300e\"} {} {\"\u300f\"} Unary Matchfix Non True CornerBracket = CornerBracket -10 670 760 1 -10 = -10 {{\"\u300c\", \"expr\", \"\u300d\"}} {\"\u300c\"} {} {\"\u300d\"} Unary Matchfix Non True FullwidthCurlyBracket = FullwidthCurlyBracket -10 670 760 1 -10 = -10 {{\"\uff5b\", \"expr\", \"\uff5d\"}} {\"\uff5b\"} {} {\"\uff5d\"} Unary Matchfix Non True BoxGroup \u2260 None -10 670 760 1 -10 {{\"\\(\", \"expr\", \"\\)\"}} \\(expr\\) {\"\\(\"} {} {\"\\)\"} Unary Matchfix Non True The interpretation of this operator depends on context. It must contain box sublanguage. Parentheses \u2260 None -10 670 760 1 -10 {{\"(\", \"expr\", \")\"}} {\"(\"} {} {\")\"} Unary Matchfix Non True NumberBase \u2260 None -10 670 760 1 -10 {{\"n\", \"^^\", \"digits\"}} {\"n\", \"^^\", \"digits\"} n^^digits {} {\"^^\"} {} Binary Infix Non True Interprets digits as a number literal in base n. The base n must be a positive integer no greater than 36. NumberMagnitude \u2260 None -10 670 760 1 -10 {{\"number\", \"*^\", \"magnitude\"}} {\"number\", \"*^\", \"magnitude\"} number*^magnitude {} {\"*^\"} {} Binary Infix Non True Gives mantissa*base^magnitude, where base^^mantissa=number and magnitude is a decimal number expressed without ^^, `, or ``. Only allowed in a number literal, and only after any ` or ``. NumberPrecisionPostfix \u2260 None -10 670 760 1 -10 {{\"number\", \"`\"}} {\"number\", \"`\"} number` {} {\"`\"} {} Unary Postfix Left True Specifies the precision of number to be $MachinePrecision. Any magnitude must come after `.\" NumberPrecision \u2260 None -10 670 760 1 -10 {{\"number\", \"`\", \"s\"}} {\"number\", \"`\", \"s\"} number`s {} {\"`\"} {} Binary Infix Non True Specifies the precision of number, where s is a positive decimal expressed without using ^^ or `. Any magnitude must come after `.\" NumberAccuracy \u2260 None -10 670 760 1 -10 {{\"number\", \"``\", \"s\"}} {\"number\", \"``\", \"s\"} number``s {} {\"``\"} {} Binary Infix Non True Specifies the accuracy (in number of digits to the right of decimal) of number, where s is a positive decimal expressed without using ^^ or `. A magnitude must come after ``. ContextPathSeparator \u2260 None -10 670 760 1 -10 {{\"symb1\", \"`\", \"symb2\"}} {\"symb1\", \"`\", \"symb2\"} symb1`symb2 {} {\"`\"} {} Non True Functions as a decimal point: either contextpath1 or contextpath2 may be empty, but not both at the same time. MessageName = MessageName 1060 750 = 750 2 = 2 850 {{\"expr\", \"::\", \"string\"}} {\"MessageName\", \"[\", \"expr\", \",\", \"\", \"string\", \"\", \"]\"} MessageName[expr, \"string\"] {} {\"::\"} {} Binary Infix Non True SlotNumber \u2260 Slot 1050 740 = 740 3 = 3 840 {{\"#\", \"n\"}} {\"Slot\", \"[\", \"n\", \"]\"} Slot[n] {\"#\"} {} {} Unary Prefix Non True SlotSequenceNumber \u2260 SlotSequence 1050 740 = 740 3 = 3 840 {{\"##\", \"n\"}} {\"SlotSequence\", \"[\", \"n\", \"]\"} SlotSequence[n] {\"##\"} {} {} Unary Prefix Non True Slot = Slot 1040 740 = 740 3 = 3 840 {{\"#\"}} {\"Slot\", \"[\", \"1\", \"]\"} Slot[1] {\"#\"} {} {} Nullary None Non True SlotSequence = SlotSequence 1040 740 = 740 3 = 3 840 {{\"##\"}} {\"SlotSequence\", \"[\", \"1\", \"]\"} SlotSequence[1] {\"##\"} {} {} Nullary None Non True Out = Out 1030 670 735 4 = 4 830 {{\"%%\", \"\u2026\", \"%\"}} {\"Out\", \"[\", \"-\", \"n\", \"]\"} Out[-n] {\"%%\"} {} {} Nullary None Non True OutNumber \u2260 Out 1020 670 735 4 = 4 830 {{\"%\", \"n\"}} {\"Out\", \"[\", \"n\", \"]\"} Out[n] {\"%\"} {} {} Unary Prefix Non True BlankHead \u2260 Blank 1010 730 = 730 5 = 5 820 {{\"_\", \"expr\"}} {\"Blank\", \"[\", \"expr\", \"]\"} Blank[expr] {\"_\"} {} {} Unary Prefix Non True BlankSequenceHead \u2260 BlankSequence 1010 730 = 730 5 = 5 820 {{\"__\", \"expr\"}} {\"BlankSequence\", \"[\", \"expr\", \"]\"} BlankSequence[expr] {\"__\"} {} {} Unary Prefix Non True BlankNullSequenceHead \u2260 BlankNullSequence 1010 730 = 730 5 = 5 820 {{\"___\", \"expr\"}} {\"BlankNullSequence\", \"[\", \"expr\", \"]\"} BlankNullSequence[expr] {\"___\"} {} {} Unary Prefix Non True NamedBlankHead \u2260 Blank 1000 730 = 730 5 = 5 820 {{\"symb\", \"_\", \"expr\"}} {\"Pattern\", \"[\", \"symb\", \",\", \"Blank\", \"[\", \"expr\", \"]\", \"]\"} Pattern[symb, Blank[expr]] {} {\"_\"} {} Binary Infix Non True NamedBlankSequenceHead \u2260 BlankSequence 1000 730 = 730 5 = 5 820 {{\"symb\", \"__\", \"expr\"}} {\"Pattern\", \"[\", \"symb\", \",\", \"BlankSequence\", \"[\", \"expr\", \"]\", \"]\"} Pattern[symb, BlankSequence[expr]] {} {\"__\"} {} Binary Infix Non True NamedBlankNullSequenceHead \u2260 BlankNullSequence 1000 730 = 730 5 = 5 820 {{\"symb\", \"___\", \"expr\"}} {\"Pattern\", \"[\", \"symb\", \",\", \"BlankNullSequence\", \"[\", \"expr\", \"]\", \"]\"} Pattern[symb, BlankNullSequence[expr]] {} {\"___\"} {} Binary Infix Non True NamedBlank \u2260 Blank 990 730 = 730 5 = 5 820 {{\"symb\", \"_\"}} {\"Pattern\", \"[\", \"symb\", \",\", \"Blank\", \"[\", \"]\", \"]\"} Pattern[symb, Blank[]] {} {\"_\"} {} Unary Postfix Non True NamedBlankSequence \u2260 BlankSequence 990 730 = 730 5 = 5 820 {{\"symb\", \"__\"}} {\"Pattern\", \"[\", \"symb\", \",\", \"BlankSequence\", \"[\", \"]\", \"]\"} Pattern[symb, BlankSequence[]] {} {\"__\"} {} Unary Postfix Non True NamedBlankOptional \u2260 Blank 990 730 = 730 5 = 5 820 {{\"symb\", \"_.\"}} {\"Optional\", \"[\", \"Pattern\", \",\", \"Blank\", \"[\", \"]\", \"]\", \"]\"} Optional[Pattern[symb, Blank[]]] {} {\"_.\"} {} Unary Postfix Non True NamedBlankNullSequence \u2260 BlankNullSequence 990 730 = 730 5 = 5 820 {{\"symb\", \"___\"}} {\"Pattern\", \"[\", \"symb\", \",\", \"BlankNullSequence\", \"[\", \"]\", \"]\"} Pattern[symb, BlankNullSequence[]] {} {\"___\"} {} Unary Postfix Non True Blank = Blank 980 730 = 730 5 = 5 820 {{\"_\"}} {\"Blank\", \"[\", \"]\"} Blank[] {\"_\"} {} {} Nullary None Non True A Blank (_) with no accompanying decoration. BlankNullSequence = BlankNullSequence 980 730 = 730 5 = 5 820 {{\"___\"}} {\"BlankNullSequence\", \"[\", \"]\"} BlankNullSequence[] {\"___\"} {} {} Nullary None Non True A BlankNullSequence (___) with no accompanying decoration. BlankOptional \u2260 Blank 980 730 = 730 5 = 5 820 {{\"_.\"}} {\"Optional\", \"[\", \"Blank\", \"]\"} Optional[Blank[]] {\"_.\"} {} {} Nullary None Non True No name or head. BlankSequence = BlankSequence 980 730 = 730 5 = 5 820 {{\"__\"}} {\"BlankSequence\", \"[\", \"]\"} BlankSequence[] {\"__\"} {} {} Nullary None Non True A BlankNullSequence (__) with no accompanying decoration. Get = Get 970 720 = 720 6 = 6 810 {{\"<<\", \"filename\"}} {\"Get\", \"[\", \"\", \"filename\"} Get[\"filename\"] {\"<<\"} {} {} Unary Prefix Right True InvisiblePrefixScriptBase = InvisiblePrefixScriptBase 960 670 715 6.5 800 = 800 {{\"\uf3b3\", \"expr\"}} {\"InvisiblePrefixScriptBase\", \"[\", \"expr\", \"]\"} {\"\uf3b3\"} {} {} Unary Prefix Right False Usage and Parse may not be correct. InvisiblePostfixScriptBase = InvisiblePostfixScriptBase 960 670 715 6.5 800 = 800 {{\"expr\", \"\uf3b4\"}} {\"InvisiblePostfixScriptBase\", \"[\", \"expr\", \"]\"} {} {\"\uf3b4\"} {} Unary Postfix Left False This operator is an invisible Unicode character and is used in the layout of displayed expressions. PartialOverscriptBox = PartialOverscriptBox 950 670 710 7 790 {{\"expr\", \"\uf356\"}} {\"FractionBox\", \"[\", \"expr\", \",\"\\[\", \"Placeholder\", \"]\"]\"} {} {\"\uf356\"} {} Unary Postfix Left False This operator is an invisible Unicode character and is used in the layout of displayed expressions. OverscriptBox \u2260 Overscript 950 670 710 7 = 7 790 {{\"expr1\", \"\\&\", \"expr2\"}} {\"OverscriptBox\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} {} {\"\\&\"} {} Binary Infix Missing[\"Unknown\"] True PartialUnderscriptBox = PartialUnderscriptBox 950 670 710 7 790 {{\"expr\", \"\uf355\"}} {\"FractionBox\", \"[\", \"expr\", \",\"\\[\", \"Placeholder\", \"]\"]\"} {} {\"\uf355\"} {} Unary Postfix Left False This operator is an invisible Unicode character and is used in the layout of displayed expressions. UnderscriptBox \u2260 Underscript 950 670 710 7 = 7 790 {{\"expr1\", \"\\+\", \"expr2\"}} {\"UnderscriptBox\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} {} {\"\\+\"} {} Binary Infix Missing[\"Unknown\"] True OverunderscriptBox \u2260 Underoverscript 940 670 700 7 \u2260 7.5 785 {{\"expr1\", \"\\&\", \"expr2\", \"\\%\", \"expr3\"}} {\"UnderoverscriptBox\", \"[\", \"expr1\", \",\", \"expr3\", \",\", \"expr2\", \"]\"} {} {\"\\&\"} {\"\\%\"} Ternary Infix Missing[\"Unknown\"] True UnderoverscriptBox \u2260 Underoverscript 940 670 700 7 \u2260 7.5 785 {{\"expr1\", \"\\+\", \"expr2\", \"\\%\", \"expr3\"}} {\"UnderoverscriptBox\", \"[\", \"expr1\", \",\", \"expr2\", \",\", \"expr3\", \"]\"} {} {\"\\+\"} {\"\\%\"} Ternary Infix Missing[\"Unknown\"] True InterpretBoxes \u2260 None 930 670 695 7.6 780 {{\"\\*\", \"expr\"}} {\"\\*\"} {} {} Unary Prefix Right True PartialSubscriptBox = PartialSubscriptBox 920 670 690 8 775 {{\"expr\", \"\uf353\"}} {\"FractionBox\", \"[\", \"expr\", \",\"\\[\", \"Placeholder\", \"]\"]\"} {} {\"\uf353\"} {} Unary Postfix Left False This operator is an invisible Unicode character and is used in the layout of displayed expressions. SubscriptBox \u2260 Subscript 920 670 690 8 = 8 775 {{\"expr1\", \"\\_\", \"expr2\"}} {\"SubscriptBox\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} {} {\"\\_\"} {} Binary Infix Missing[\"Unknown\"] True SubsuperscriptBox \u2260 Subsuperscript 920 670 690 8 = 8 775 {{\"expr1\", \"\\_\", \"expr2\", \"\\%\", \"expr3\"}} {\"SubsuperscriptBox\", \"[\", \"expr1\", \",\", \"expr2\", \",\", \"expr3\", \"]\"} {} {\"\\_\"} {\"\\%\"} Ternary Infix Missing[\"Unknown\"] True PatternTest = PatternTest 910 680 = 680 9 = 9 770 {{\"expr1\", \"?\", \"expr2\"}} {\"PatternTest\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} PatternTest[expr1, expr2] {} {\"?\"} {} Binary Infix Missing[\"Unknown\"] True InlinePart = InlinePart 900 670 675 9.5 763 = 763 {{\"expr1\", \"\uf51e\", \"expr2\"}} {\"InlinePart\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} RowBox[List[expr1, InlinePart, expr2]] {} {\"\uf51e\"} {} Binary Infix Right False \"InlinePart or @> was an operator that was introduced in one of the pre-release/betas for version 10 and subsequently removed before public release. It was briefly available publicly in the Raspberry Pi version of Wolfram Language that co-existed with the pre-releases at the time. The operator allowed you to access elements of a list with an infix operator.\" https://mathematica.stackexchange.com/questions/134506/inlinepart-what-is-it-and-what-happened-to-it Part = Part 890 670 = 670 10 = 10 762 {{\"expr1\", \"[[\", \"expr2\", \"]]\"}, {\"expr1\", \"\u301a\", \"expr2\", \"\u301b\"}} {\"Part\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Part[expr1, expr2, \\[Ellipsis]] {} {\"[[\", \"\u301a\"} {\"]]\", \"\u301b\"} n-ary Postfix Left True FunctionApply \u2260 None 890 670 = 670 10 761 {{\"expr1\", \"[\", \"expr2\", \"]\"}} {\"expr1\", \"[\", \"expr2\", \",\", \"\u2026\", \"]\"} expr1[expr2, \\[Ellipsis]] {} {\"[\"} {\"]\"} n-ary Postfix Left True Decrement = Decrement 880 660 \u2260 665 11 = 11 760 {{\"expr\", \"--\"}} {\"Decrement\", \"[\", \"expr\", \"]\"} Decrement[expr] {} {\"--\"} {} Unary Postfix Left True Increment = Increment 880 660 \u2260 665 11 = 11 760 {{\"expr\", \"++\"}} {\"Increment\", \"[\", \"expr\", \"]\"} Increment[expr] {} {\"++\"} {} Unary Postfix Left True PreDecrement = PreDecrement 870 660 = 660 12 = 12 750 {{\"--\", \"expr\"}} {\"PreDecrement\", \"[\", \"expr\", \"]\"} PreDecrement[expr] {\"--\"} {} {} Unary Prefix Right True PreIncrement = PreIncrement 870 660 = 660 12 = 12 750 {{\"++\", \"expr\"}} {\"PreIncrement\", \"[\", \"expr\", \"]\"} PreIncrement[expr] {\"++\"} {} {} Unary Prefix Right True Composition = Composition 860 625 \u2260 655 13 = 13 740 {{\"expr1\", \"@*\", \"expr2\"}} {\"Composition\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Composition[expr1, expr2] {} {\"@*\"} {} Binary Infix None True RightComposition = RightComposition 850 624 \u2260 650 13 = 13 740 {{\"expr1\", \"/*\", \"expr2\"}} {\"RightComposition\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} RightComposition[expr1, expr2] {} {\"/*\"} {} Binary Infix None True FunctionApplyPrefix \u2260 Prefix 840 640 = 640 14 730 = 730 {{\"expr1\", \"@\", \"expr2\"}, {\"expr1\", \"\uf76d\", \"expr2\"}} {\"expr1\", \"[\", \"expr2\", \"]\"} expr1[expr2] {} {\"@\", \"\uf76d\"} {} Binary Infix Right True Operator Notations includes usages with invisible unicode characters. FunctionApplyInfix \u2260 Infix 830 630 = 630 15 720 {{\"expr1\", \"~\", \"expr2\", \"~\", \"expr3\"}} {\"expr2\", \"[\", \"expr1\", \",\", \"expr3\", \"]\"} expr2[expr1, expr3] {} {\"~\"} {} Ternary Infix Left True Infix[f[x,y]] will display as x~f~y. Precedence identifies Infix with this operator, and Precedence[Infix]==30 which is almost correct. Apply = Apply 820 620 \u2260 626 16 = 16 710 {{\"expr1\", \"@@\", \"expr2\"}} {\"Apply\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Apply[expr1, expr2] {} {\"@@\"} {} Binary Infix Right True ApplyFirstLevel \u2260 Apply 810 620 \u2260 625 16 = 16 710 {{\"expr1\", \"@@@\", \"expr2\"}} {\"Apply\", \"[\", \"expr1\", \",\", \"expr2\", \"{\", \"1\", \"}\", \"]\"} Apply[expr1, expr2, List[1]] {} {\"@@@\"} {} Binary Infix Right True Map = Map 800 620 = 620 16 = 16 710 {{\"expr1\", \"/@\", \"expr2\"}} {\"Map\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Map[expr1, expr2] {} {\"/@\"} {} Binary Infix Right True MapAll = MapAll 800 620 = 620 16 = 16 710 {{\"expr1\", \"//@\", \"expr2\"}} {\"MapAll\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} MapAll[expr1, expr2] {} {\"//@\"} {} Binary Infix Right True Factorial = Factorial 790 610 = 610 17 = 17 700 {{\"expr\", \"!\"}} {\"Factorial\", \"[\", \"expr\", \"]\"} Factorial[expr] {} {\"!\"} {} Unary Postfix Left True Factorial2 = Factorial2 790 610 = 610 17 = 17 700 {{\"expr\", \"!!\"}} {\"Factorial2\", \"[\", \"expr\", \"]\"} Factorial2[expr] {} {\"!!\"} {} Unary Postfix Left True Conjugate = Conjugate 780 670 605 18 = 18 695 = 695 {{\"expr\", \"\uf3c8\"}} {\"Conjugate\", \"[\", \"expr\", \"]\"} Conjugate[expr] {} {\"\uf3c8\"} {} Unary Postfix Left True ConjugateTranspose = ConjugateTranspose 780 670 605 18 = 18 695 = 695 {{\"expr\", \"\uf3c9\"}, {\"expr\", \"\uf3ce\"}} {\"ConjugateTranspose\", \"[\", \"expr\", \"]\"} ConjugateTranspose[expr] {} {\"\uf3c9\", \"\uf3ce\"} {} Unary Postfix Left True SuperDagger = SuperDagger 780 0 \u2260 605 18 695 {{\"expr\", \"^\u2020\"}} {\"SuperDagger\", \"[\", \"expr\", \"]\"} Power[expr, \\[Dagger]] {} {\"^\u2020\"} {} Unary Postfix Left True Transpose = Transpose 780 670 605 18 = 18 695 = 695 {{\"expr\", \"\uf3c7\"}} {\"Transpose\", \"[\", \"expr\", \"]\"} Transpose[expr] {} {\"\uf3c7\"} {} Unary Postfix Left True Derivative = Derivative 770 670 604 19 = 19 680 {{\"expr\", \"''\"}} {\"Derivative\", \"[\", \"n\", \"]\", \"[\", \"expr\", \"]\"} Derivative[n][expr] {} {\"''\"} {} Unary Postfix Left True StringJoin = StringJoin 760 600 = 600 20 = 20 670 {{\"expr1\", \"<>\", \"expr2\"}} {\"StringJoin\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} StringJoin[expr1, expr2] {} {\"<>\"} {} Binary Infix None True Power = Power 750 590 = 590 21 = 21 660 {{\"expr1\", \"^\", \"expr2\"}} {\"Power\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Power[expr1, expr2] {} {\"^\"} {} Binary Infix Right True PartialSuperscriptBox = PartialSuperscriptBox 750 670 590 21 660 {{\"expr\", \"\uf354\"}} {\"FractionBox\", \"[\", \"expr\", \",\"\\[\", \"Placeholder\", \"]\"]\"} {} {\"\uf354\"} {} Unary Postfix Left False This operator is an invisible Unicode character and is used in the layout of displayed expressions. SuperscriptBox = SuperscriptBox 750 590 = 590 21 = 21 660 {{\"expr1\", \"\\^\", \"expr2\"}} {\"SuperscriptBox\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} {} {\"\\^\"} {} Binary Infix Right True SupersubscriptBox \u2260 SubsuperscriptBox 750 690 \u2260 590 21 = 21 660 {{\"expr1\", \"\\^\", \"expr2\", \"\\%\", \"expr3\"}} {\"SubsuperscriptBox\", \"[\", \"expr1\", \",\", \"expr3\", \",\", \"expr2\", \"]\"} {} {\"\\^\"} {\"\\%\"} Ternary Infix Right True DoubleDownArrow = DoubleDownArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21d3\", \"y\"}} {\"DoubleDownArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleDownArrow[x, y] {} {\"\u21d3\"} {} Binary Infix None False DoubleLongLeftArrow = DoubleLongLeftArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u27f8\", \"y\"}} {\"DoubleLongLeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleLongLeftArrow[x, y] {} {\"\u27f8\"} {} Binary Infix None False DoubleLongLeftRightArrow = DoubleLongLeftRightArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u27fa\", \"y\"}} {\"DoubleLongLeftRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleLongLeftRightArrow[x, y] {} {\"\u27fa\"} {} Binary Infix None False DoubleLongRightArrow = DoubleLongRightArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u27f9\", \"y\"}} {\"DoubleLongRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleLongRightArrow[x, y] {} {\"\u27f9\"} {} Binary Infix None False DoubleUpArrow = DoubleUpArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21d1\", \"y\"}} {\"DoubleUpArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleUpArrow[x, y] {} {\"\u21d1\"} {} Binary Infix None False DoubleUpDownArrow = DoubleUpDownArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21d5\", \"y\"}} {\"DoubleUpDownArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleUpDownArrow[x, y] {} {\"\u21d5\"} {} Binary Infix None False DownArrow = DownArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2193\", \"y\"}} {\"DownArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DownArrow[x, y] {} {\"\u2193\"} {} Binary Infix None False DownArrowBar = DownArrowBar 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2913\", \"y\"}} {\"DownArrowBar\", \"[\", \"x\", \",\", \"y\", \"]\"} DownArrowBar[x, y] {} {\"\u2913\"} {} Binary Infix None False DownArrowUpArrow = DownArrowUpArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21f5\", \"y\"}} {\"DownArrowUpArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DownArrowUpArrow[x, y] {} {\"\u21f5\"} {} Binary Infix None False DownTeeArrow = DownTeeArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21a7\", \"y\"}} {\"DownTeeArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DownTeeArrow[x, y] {} {\"\u21a7\"} {} Binary Infix None False LeftDownTeeVector = LeftDownTeeVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2961\", \"y\"}} {\"LeftDownTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftDownTeeVector[x, y] {} {\"\u2961\"} {} Binary Infix None False LeftDownVector = LeftDownVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21c3\", \"y\"}} {\"LeftDownVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftDownVector[x, y] {} {\"\u21c3\"} {} Binary Infix None False LeftDownVectorBar = LeftDownVectorBar 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2959\", \"y\"}} {\"LeftDownVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftDownVectorBar[x, y] {} {\"\u2959\"} {} Binary Infix None False LeftUpDownVector = LeftUpDownVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2951\", \"y\"}} {\"LeftUpDownVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftUpDownVector[x, y] {} {\"\u2951\"} {} Binary Infix None False LeftUpTeeVector = LeftUpTeeVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2960\", \"y\"}} {\"LeftUpTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftUpTeeVector[x, y] {} {\"\u2960\"} {} Binary Infix None False LeftUpVector = LeftUpVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21bf\", \"y\"}} {\"LeftUpVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftUpVector[x, y] {} {\"\u21bf\"} {} Binary Infix None False LeftUpVectorBar = LeftUpVectorBar 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2958\", \"y\"}} {\"LeftUpVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftUpVectorBar[x, y] {} {\"\u2958\"} {} Binary Infix None False LongLeftArrow = LongLeftArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u27f5\", \"y\"}} {\"LongLeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LongLeftArrow[x, y] {} {\"\u27f5\"} {} Binary Infix None False LongLeftRightArrow = LongLeftRightArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u27f7\", \"y\"}} {\"LongLeftRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LongLeftRightArrow[x, y] {} {\"\u27f7\"} {} Binary Infix None False LongRightArrow = LongRightArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u27f6\", \"y\"}} {\"LongRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LongRightArrow[x, y] {} {\"\u27f6\"} {} Binary Infix None False ReverseUpEquilibrium = ReverseUpEquilibrium 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u296f\", \"y\"}} {\"ReverseUpEquilibrium\", \"[\", \"x\", \",\", \"y\", \"]\"} ReverseUpEquilibrium[x, y] {} {\"\u296f\"} {} Binary Infix None False RightDownTeeVector = RightDownTeeVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u295d\", \"y\"}} {\"RightDownTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} RightDownTeeVector[x, y] {} {\"\u295d\"} {} Binary Infix None False RightDownVector = RightDownVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21c2\", \"y\"}} {\"RightDownVector\", \"[\", \"x\", \",\", \"y\", \"]\"} RightDownVector[x, y] {} {\"\u21c2\"} {} Binary Infix None False RightDownVectorBar = RightDownVectorBar 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2955\", \"y\"}} {\"RightDownVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} RightDownVectorBar[x, y] {} {\"\u2955\"} {} Binary Infix None False RightUpDownVector = RightUpDownVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u294f\", \"y\"}} {\"RightUpDownVector\", \"[\", \"x\", \",\", \"y\", \"]\"} RightUpDownVector[x, y] {} {\"\u294f\"} {} Binary Infix None False RightUpTeeVector = RightUpTeeVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u295c\", \"y\"}} {\"RightUpTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} RightUpTeeVector[x, y] {} {\"\u295c\"} {} Binary Infix None False RightUpVector = RightUpVector 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21be\", \"y\"}} {\"RightUpVector\", \"[\", \"x\", \",\", \"y\", \"]\"} RightUpVector[x, y] {} {\"\u21be\"} {} Binary Infix None False RightUpVectorBar = RightUpVectorBar 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2954\", \"y\"}} {\"RightUpVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} RightUpVectorBar[x, y] {} {\"\u2954\"} {} Binary Infix None False ShortDownArrow = ShortDownArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\uf52b\", \"y\"}} {\"ShortDownArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} ShortDownArrow[x, y] {} {\"\uf52b\"} {} Binary Infix None False ShortUpArrow = ShortUpArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\uf52a\", \"y\"}} {\"ShortUpArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} ShortUpArrow[x, y] {} {\"\uf52a\"} {} Binary Infix None False UpArrow = UpArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2191\", \"y\"}} {\"UpArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} UpArrow[x, y] {} {\"\u2191\"} {} Binary Infix None False UpArrowBar = UpArrowBar 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2912\", \"y\"}} {\"UpArrowBar\", \"[\", \"x\", \",\", \"y\", \"]\"} UpArrowBar[x, y] {} {\"\u2912\"} {} Binary Infix None False UpArrowDownArrow = UpArrowDownArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21c5\", \"y\"}} {\"UpArrowDownArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} UpArrowDownArrow[x, y] {} {\"\u21c5\"} {} Binary Infix None False UpDownArrow = UpDownArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u2195\", \"y\"}} {\"UpDownArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} UpDownArrow[x, y] {} {\"\u2195\"} {} Binary Infix None False UpEquilibrium = UpEquilibrium 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u296e\", \"y\"}} {\"UpEquilibrium\", \"[\", \"x\", \",\", \"y\", \"]\"} UpEquilibrium[x, y] {} {\"\u296e\"} {} Binary Infix None False UpTeeArrow = UpTeeArrow 740 580 = 580 21.5 650 = 650 {{\"x\", \"\u21a5\", \"y\"}} {\"UpTeeArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} UpTeeArrow[x, y] {} {\"\u21a5\"} {} Binary Infix None False Sqrt = Sqrt 730 670 570 22 = 22 650 \u2260 640 {{\"\u221a\", \"expr\"}} {\"Sqrt\", \"[\", \"expr\", \"]\"} Sqrt[expr] {\"\u221a\"} {} {} Unary Prefix Right True RadicalBox = RadicalBox 730 670 570 22 = 22 640 {{\"\\@\", \"expr1\", \"\\%\", \"expr2\"}} {\"RadicalBox\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} {\"\\@\"} {} {\"\\%\"} Binary Prefix Right True SqrtBox \u2260 Sqrt 730 670 570 22 = 22 650 \u2260 640 {{\"\\@\", \"expr\"}} {\"SqrtBox\", \"[\", \"expr\", \"]\"} {\"\\@\"} {} {} Unary Prefix Right True CapitalDifferentialD = CapitalDifferentialD 720 550 \u2260 560 23 630 = 630 {{\"\uf74b\", \"x\"}} {\"CapitalDifferentialD\", \"[\", \"x\", \"]\"} CapitalDifferentialD[x] {\"\uf74b\"} {} {} Unary Prefix Right False DifferentialD = DifferentialD 720 550 \u2260 560 23 630 = 630 {{\"\uf74c\", \"x\"}} {\"DifferentialD\", \"[\", \"x\", \"]\"} DifferentialD[x] {\"\uf74c\"} {} {} Unary Prefix Right False DifferenceDelta = DifferenceDelta 710 550 = 550 24 = 24 620 = 620 {{\"\uf4a4\", \"expr\"}} {\"DifferenceDelta\", \"[\", \"expr\", \"]\"} {\"\uf4a4\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. DiscreteRatio = DiscreteRatio 710 550 = 550 24 = 24 620 = 620 {{\"\uf4a5\", \"expr\"}} {\"DiscreteRatio\", \"[\", \"expr\", \"]\"} {\"\uf4a5\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. DiscreteShift = DiscreteShift 710 550 = 550 24 = 24 620 = 620 {{\"\uf4a3\", \"expr\"}} {\"DiscreteShift\", \"[\", \"expr\", \"]\"} {\"\uf4a3\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. Laplacian = Laplacian 710 670 550 24 620 = 620 {{\"\u2206\", \"expr\"}} {\"Laplacian\", \"[\", \"expr\", \"]\"} {\"\u2206\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. PartialD = PartialD 710 670 550 24 = 24 620 = 620 {{\"\u2202\", \"expr\"}} {\"PartialD\", \"[\", \"expr\", \"]\"} {\"\u2202\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. Del = Del 710 550 = 550 24 = 24 620 = 620 {{\"\u2207\", \"expr\"}} {\"Del\", \"[\", \"expr\", \"]\"} Del[expr] {\"\u2207\"} {} {} Unary Prefix Right False Gradient = Gradient 700 550 \u2260 545 24 615 = 615 {{\"\uf3d6\", \"expr\"}} {\"Gradient\", \"[\", \"expr\", \"]\"} {\"\uf3d6\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. Square = Square 690 540 = 540 25 = 25.0 610 \u2260 611 {{\"\uf520\", \"expr\"}} {\"Square\", \"[\", \"expr\", \"]\"} Square[expr] {\"\uf520\"} {} {} Unary Prefix Right False Piecewise = Piecewise 680 480 \u2260 535 1 \u2260 25.5 600 \u2260 610 {{\"\uf361\", \"expr\"}} {\"Piecewise\", \"[\", \"expr\", \"]\"} {\"\uf361\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. SmallCircle = SmallCircle 670 530 = 530 25 \u2260 25.6 607 \u2260 609 {{\"expr1\", \"\u2218\", \"expr2\"}} {\"SmallCircle\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} SmallCircle[expr1, expr2] {} {\"\u2218\"} {} Binary Infix None False CircleDot = CircleDot 660 520 = 520 26, 35, 37 \u2260 26 605 \u2260 608 {{\"expr1\", \"\u2299\", \"expr2\"}} {\"CircleDot\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} CircleDot[expr1, expr2] {} {\"\u2299\"} {} Binary Infix None False NonCommutativeMultiply = NonCommutativeMultiply 650 510 = 510 27 = 27 607 {{\"expr1\", \"**\", \"expr2\"}} {\"NonCommutativeMultiply\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} NonCommutativeMultiply[expr1, expr2] {} {\"**\"} {} Binary Infix None True Cross = Cross 640 500 = 500 28 = 28 603 \u2260 606 {{\"expr1\", \"\uf4a0\", \"expr2\"}} {\"Cross\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Cross[expr1, expr2] {} {\"\uf4a0\"} {} Binary Infix None True Dot = Dot 630 490 = 490 29 = 29 605 {{\"expr1\", \".\", \"expr2\"}} {\"Dot\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Dot[expr1, expr2] {} {\".\"} {} Binary Infix None True TensorWedge = TensorWedge 620 500 \u2260 488 29.5 603 \u2260 604 {{\"expr1\", \"\uf3db\", \"expr2\"}} {\"TensorWedge\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} TensorWedge[expr1, expr2] {} {\"\uf3db\"} {} Binary Infix None True TensorProduct = TensorProduct 610 495 \u2260 487 29.6 602 \u2260 603 {{\"expr1\", \"\uf3da\", \"expr2\"}} {\"TensorProduct\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} TensorProduct[expr1, expr2] {} {\"\uf3da\"} {} Binary Infix None True PermutationProduct = PermutationProduct 600 520 \u2260 486 29.7 605 \u2260 602 {{\"expr1\", \"\uf3de\", \"expr2\"}} {\"PermutationProduct\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} PermutationProduct[expr1, expr2] {} {\"\uf3de\"} {} Binary Infix None True Curl = Curl 590 670 485 29.8 601 = 601 {{\"\uf3d8\", \"expr\"}} {\"Curl\", \"[\", \"expr\", \"]\"} {\"\uf3d8\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. Divergence = Divergence 590 550 \u2260 485 29.8 601 = 601 {{\"\uf3d7\", \"expr\"}} {\"Divergence\", \"[\", \"expr\", \"]\"} {\"\uf3d7\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. UnaryMinusPlus \u2260 MinusPlus 580 310 \u2260 480 30 = 30 430 \u2260 600 {{\"\u2213\", \"expr\"}} {\"MinusPlus\", \"[\", \"expr\", \"]\"} MinusPlus[expr] {\"\u2213\"} {} {} Unary Prefix Right False UnaryPlusMinus \u2260 PlusMinus 580 310 \u2260 480 30 = 30 430 \u2260 600 {{\"\u00b1\", \"expr\"}} {\"PlusMinus\", \"[\", \"expr\", \"]\"} PlusMinus[expr] {\"\u00b1\"} {} {} Unary Prefix Right False Minus = Minus 580 480 = 480 30 = 30 430 \u2260 600 {{\"-\", \"expr\"}, {\"\u2212\", \"expr\"}} {\"Minus\", \"[\", \"expr\", \"]\"} Times[-1, expr] {\"-\", \"\u2212\"} {} {} Unary Prefix Right True Operator Notations includes usages with invisible unicode characters. UnaryPlus \u2260 Plus 580 310 \u2260 480 30 600 {{\"+\", \"expr\"}} {\"Plus\", \"[\", \"expr\", \"]\"} Plus[expr] {\"+\"} {} {} Unary Prefix Right True Converts to expr on input. Divides = Divides 570 670 470 31 590 = 590 {{\"expr1\", \"\u2223\", \"expr2\"}} {\"Divides\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Divisible[expr2, expr1] {} {\"\u2223\"} {} Binary Infix None True PartialFractionBox = PartialFractionBox 570 670 470 31 590 {{\"expr\", \"\uf350\"}} {\"FractionBox\", \"[\", \"expr\", \",\"\\[\", \"Placeholder\", \"]\"]\"} {} {\"\uf350\"} {} Unary Postfix Left False This operator is an invisible Unicode character and is used in the layout of displayed expressions. FractionBox = FractionBox 570 670 470 31 590 {{\"expr1\", \"\\/\", \"expr2\"}} {\"FractionBox\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} {} {\"\\/\"} {} Binary Infix Left True Divide = Divide 570 470 = 470 31 = 31 590 = 590 {{\"expr1\", \"/\", \"expr2\"}, {\"expr1\", \"\u00f7\", \"expr2\"}, {\"expr1\", \"\u2215\", \"expr2\"}} {\"Divide\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Times[expr1, Power[expr2, -1]] {} {\"/\", \"\u00f7\", \"\u2215\"} {} Binary Infix Left True Backslash = Backslash 560 460 = 460 32 = 32 580 = 580 {{\"expr1\", \"\u2216\", \"expr2\"}} {\"Backslash\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Backslash[expr1, expr2] {} {\"\u2216\"} {} Binary Infix None False Diamond = Diamond 550 450 = 450 33 = 33 570 = 570 {{\"expr1\", \"\u22c4\", \"expr2\"}} {\"Diamond\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Diamond[expr1, expr2] {} {\"\u22c4\"} {} Binary Infix None False Wedge = Wedge 540 440 = 440 34 = 34 560 = 560 {{\"expr1\", \"\u22c0\", \"expr2\"}} {\"Wedge\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Wedge[expr1, expr2] {} {\"\u22c0\"} {} Binary Infix None False Vee = Vee 530 430 = 430 35 550 = 550 {{\"x\", \"\u22c1\", \"y\"}} {\"Vee\", \"[\", \"x\", \",\", \"y\", \"]\"} Vee[x, y] {} {\"\u22c1\"} {} Binary Infix None False CircleTimes = CircleTimes 520 420 = 420 36 540 = 540 {{\"expr1\", \"\u2297\", \"expr2\"}} {\"CircleTimes\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} CircleTimes[expr1, expr2] {} {\"\u2297\"} {} Binary Infix None False CenterDot = CenterDot 510 410 = 410 37 530 = 530 {{\"x\", \"\u00b7\", \"y\"}} {\"CenterDot\", \"[\", \"x\", \",\", \"y\", \"]\"} CenterDot[x, y] {} {\"\u00b7\"} {} Binary Infix None False Times = Times 500 400 = 400 38 = 38 520 = 520 {{\"expr1\", \"*\", \"expr2\"}, {\"expr1\", \"expr2\"}, {\"expr1\", \"\u00d7\", \"expr2\"}, {\"expr1\", \"\u2062\", \"expr2\"}} {\"Times\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Times[expr1, expr2] {} {\"*\", \"\u00d7\", \"\u2062\"} {} Nullary None None True Operator Notations includes usages with invisible unicode characters. Star = Star 490 390 = 390 39 = 39 510 = 510 {{\"expr1\", \"\u22c6\", \"expr2\"}} {\"Star\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Star[expr1, expr2] {} {\"\u22c6\"} {} Binary Infix None False Product = Product 480 380 = 380 40 = 40 500 = 500 {{\"\u220f\", \"expr\"}} {\"Product\", \"[\", \"expr\", \"]\"} {\"\u220f\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. ContinuedFractionK = ContinuedFractionK 480 380 = 380 40 500 = 500 {{\"\uf3d9\", \"expr\"}} {\"ContinuedFractionK\", \"[\", \"expr\", \"]\"} {\"\uf3d9\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. VerticalTilde = VerticalTilde 470 370 = 370 41 = 41 490 = 490 {{\"expr1\", \"\u2240\", \"expr2\"}} {\"VerticalTilde\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} VerticalTilde[expr1, expr2] {} {\"\u2240\"} {} Binary Infix None False Coproduct = Coproduct 460 360 = 360 42 = 42 500 = 500 {{\"expr1\", \"\u2210\", \"expr2\"}} {\"Coproduct\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Coproduct[expr1, expr2] {} {\"\u2210\"} {} Binary Infix None False Cap = Cap 450 350 = 350 43 \u2260 42.5 470 = 470 {{\"expr1\", \"\u2322\", \"expr2\"}} {\"Cap\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Cap[expr1, expr2] {} {\"\u2322\"} {} Binary Infix None False Cup = Cup 440 340 = 340 43 = 43 460 = 460 {{\"expr1\", \"\u2323\", \"expr2\"}} {\"Cup\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Cup[expr1, expr2] {} {\"\u2323\"} {} Binary Infix None False CircleMinus = CircleMinus 430 330 = 330 44 = 44 450 = 450 {{\"expr1\", \"\u2296\", \"expr2\"}} {\"CircleMinus\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} CircleMinus[expr1, expr2] {} {\"\u2296\"} {} Binary Infix Left False CirclePlus = CirclePlus 430 330 = 330 44 = 44 450 = 450 {{\"expr1\", \"\u2295\", \"expr2\"}} {\"CirclePlus\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} CirclePlus[expr1, expr2] {} {\"\u2295\"} {} Binary Infix None False Sum = Sum 420 320 \u2260 325 45 = 45 440 \u2260 445 {{\"\u2211\", \"expr\"}} {\"Sum\", \"[\", \"expr\", \"]\"} Sum[expr] {\"\u2211\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. Integrate \u2260 Integral 420 325 = 325 23 \u2260 45 455 \u2260 445 {{\"\u222b\", \"expr1\", \"\uf74c\", \"expr2\"}} {\"Integrate\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Integrate[expr1, expr2] {\"\u222b\"} {} {\"\uf74c\"} Binary Prefix Right True ClockwiseContourIntegral = ClockwiseContourIntegral 420 670 325 45 455 \u2260 445 {{\"\u2232\", \"expr1\", \"\uf74c\", \"expr2\"}} {\"ClockwiseContourIntegral\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Integrate[expr1, expr2] {\"\u2232\"} {} {\"\uf74c\"} Unary Prefix Right True Usage and Parse may not be correct. ContourIntegral = ContourIntegral 420 670 325 45 455 \u2260 445 {{\"\u222e\", \"expr1\", \"\uf74c\", \"expr2\"}} {\"ContourIntegral\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Integrate[expr1, expr2] {\"\u222e\"} {} {\"\uf74c\"} Unary Prefix Right True Usage and Parse may not be correct. CounterClockwiseContourIntegral = CounterClockwiseContourIntegral 420 670 325 45 455 \u2260 445 {{\"\u2233\", \"expr1\", \"\uf74c\", \"expr2\"}} {\"CounterClockwiseContourIntegral\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Integrate[expr1, expr2] {\"\u2233\"} {} {\"\uf74c\"} Unary Prefix Right True Usage and Parse may not be correct. DoubleContourIntegral = DoubleContourIntegral 420 670 325 45 455 \u2260 445 {{\"\u222f\", \"expr1\", \"\uf74c\", \"expr2\"}} {\"DoubleContourIntegral\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Integrate[expr1, expr2] {\"\u222f\"} {} {\"\uf74c\"} Unary Prefix Right True Usage and Parse may not be correct. ExpectationE = ExpectationE 420 325 = 325 45 455 \u2260 445 {{\"\uf3dd\", \"expr\"}} {\"ExpectationE\", \"[\", \"expr\", \"]\"} {\"\uf3dd\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. ProbabilityPr = ProbabilityPr 420 325 = 325 45 455 \u2260 445 {{\"\uf3dc\", \"expr\"}} {\"ProbabilityPr\", \"[\", \"expr\", \"]\"} {\"\uf3dc\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. Limit = Limit 410 320 = 320 45.5 440 = 440 {{\"\uf438\", \"expr\"}} {\"Limit\", \"[\", \"expr\", \"]\"} {\"\uf438\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. MaxLimit = MaxLimit 410 320 = 320 45.5 440 = 440 {{\"\uf439\", \"expr\"}} {\"MaxLimit\", \"[\", \"expr\", \"]\"} {\"\uf439\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. MinLimit = MinLimit 410 320 = 320 45.5 440 = 440 {{\"\uf43a\", \"expr\"}} {\"MinLimit\", \"[\", \"expr\", \"]\"} {\"\uf43a\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. MinusPlus = MinusPlus 400 310 = 310 46 = 46 430 = 430 {{\"expr1\", \"\u2213\", \"expr2\"}} {\"MinusPlus\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} MinusPlus[expr1, expr2] {} {\"\u2213\"} {} Binary Infix Left False Plus = Plus 400 310 = 310 46 = 46 430 {{\"expr1\", \"+\", \"expr2\"}, {\"expr1\", \"\uf39e\", \"expr2\"}} {\"Plus\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Plus[expr1, expr2] {} {\"+\", \"\uf39e\"} {} Binary Infix None True Operator Notations includes usages with invisible unicode characters. PlusMinus = PlusMinus 400 310 = 310 46 = 46 430 = 430 {{\"expr1\", \"\u00b1\", \"expr2\"}} {\"PlusMinus\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} PlusMinus[expr1, expr2] {} {\"\u00b1\"} {} Binary Infix Left False Subtract = Subtract 400 310 = 310 46 = 46 430 = 430 {{\"expr1\", \"-\", \"expr2\"}, {\"expr1\", \"\u2212\", \"expr2\"}} {\"Subtract\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Plus[expr1, Times[-1, expr2]] {} {\"-\", \"\u2212\"} {} Binary Infix Left True Operator Notations includes usages with invisible unicode characters. Intersection = Intersection 390 305 = 305 47 = 47 420 = 420 {{\"expr1\", \"\u22c2\", \"expr2\"}} {\"Intersection\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Intersection[expr1, expr2] {} {\"\u22c2\"} {} Binary Infix None True Span = Span 390 305 = 305 49 \u2260 47 420 {{\"i\", \";;\", \"j\", \";;\", \"k\"}} {\"Span\", \"[\", \"i\", \",\", \"j\", \",\", \"k\", \"]\"} Span[i, j, k] {\";;\"} {\";;\"} {\";;\"} Ternary Infix Non True SquareIntersection = SquareIntersection 390 305 = 305 47 420 = 420 {{\"x\", \"\u2293\", \"y\"}} {\"SquareIntersection\", \"[\", \"x\", \",\", \"y\", \"]\"} SquareIntersection[x, y] {} {\"\u2293\"} {} Binary Infix None False SquareUnion = SquareUnion 380 300 = 300 48 410 = 410 {{\"x\", \"\u2294\", \"y\"}} {\"SquareUnion\", \"[\", \"x\", \",\", \"y\", \"]\"} SquareUnion[x, y] {} {\"\u2294\"} {} Binary Infix None False Union = Union 380 300 = 300 48 = 48 410 = 410 {{\"expr1\", \"\u22c3\", \"expr2\"}} {\"Union\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Union[expr1, expr2] {} {\"\u22c3\"} {} Binary Infix None True UnionPlus = UnionPlus 380 300 = 300 48 410 = 410 {{\"x\", \"\u228e\", \"y\"}} {\"UnionPlus\", \"[\", \"x\", \",\", \"y\", \"]\"} UnionPlus[x, y] {} {\"\u228e\"} {} Binary Infix None False DirectedEdge = DirectedEdge 370 295 = 295 49.0 395 = 395 {{\"expr1\", \"\uf3d5\", \"expr2\"}} {\"DirectedEdge\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} DirectedEdge[expr1, expr2] {} {\"\uf3d5\"} {} Binary Infix None True UndirectedEdge = UndirectedEdge 370 295 = 295 49.0 395 = 395 {{\"expr1\", \"\uf3d4\", \"expr2\"}} {\"UndirectedEdge\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} UndirectedEdge[expr1, expr2] {} {\"\uf3d4\"} {} Binary Infix None True Congruent = Congruent 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2261\", \"y\"}} {\"Congruent\", \"[\", \"x\", \",\", \"y\", \"]\"} Congruent[x, y] {} {\"\u2261\"} {} Binary Infix None False CupCap = CupCap 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u224d\", \"y\"}} {\"CupCap\", \"[\", \"x\", \",\", \"y\", \"]\"} CupCap[x, y] {} {\"\u224d\"} {} Binary Infix None False DotEqual = DotEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2250\", \"y\"}} {\"DotEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} DotEqual[x, y] {} {\"\u2250\"} {} Binary Infix None False Equal = Equal 360 290 = 290 50 = 50.0 390 = 390 {{\"expr1\", \"==\", \"expr2\"}, {\"expr1\", \"\uf431\", \"expr2\"}, {\"expr1\", \"\uf7d9\", \"expr2\"}} {\"Equal\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Equal[expr1, expr2] {} {\"==\", \"\uf431\", \"\uf7d9\"} {} Binary Infix None True EqualTilde = EqualTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2242\", \"y\"}} {\"EqualTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} EqualTilde[x, y] {} {\"\u2242\"} {} Binary Infix None False Equilibrium = Equilibrium 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u21cc\", \"y\"}} {\"Equilibrium\", \"[\", \"x\", \",\", \"y\", \"]\"} Equilibrium[x, y] {} {\"\u21cc\"} {} Binary Infix None False Greater = Greater 360 290 = 290 50 = 50.0 390 {{\"expr1\", \">\", \"expr2\"}} {\"Greater\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Greater[expr1, expr2] {} {\">\"} {} Binary Infix None True GreaterEqual = GreaterEqual 360 290 = 290 50 = 50.0 390 = 390 {{\"expr1\", \">=\", \"expr2\"}, {\"expr1\", \"\u2265\", \"expr2\"}} {\"GreaterEqual\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} GreaterEqual[expr1, expr2] {} {\">=\", \"\u2265\"} {} Binary Infix None True GreaterEqualLess = GreaterEqualLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22db\", \"y\"}} {\"GreaterEqualLess\", \"[\", \"x\", \",\", \"y\", \"]\"} GreaterEqualLess[x, y] {} {\"\u22db\"} {} Binary Infix None False GreaterFullEqual = GreaterFullEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2267\", \"y\"}} {\"GreaterFullEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} GreaterFullEqual[x, y] {} {\"\u2267\"} {} Binary Infix None False GreaterGreater = GreaterGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u226b\", \"y\"}} {\"GreaterGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} GreaterGreater[x, y] {} {\"\u226b\"} {} Binary Infix None False GreaterLess = GreaterLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2277\", \"y\"}} {\"GreaterLess\", \"[\", \"x\", \",\", \"y\", \"]\"} GreaterLess[x, y] {} {\"\u2277\"} {} Binary Infix None False GreaterSlantEqual = GreaterSlantEqual 360 670 290 50.0 390 = 390 {{\"x\", \"\u2a7e\", \"y\"}} {\"GreaterEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} GreaterEqual[x, y] {} {\"\u2a7e\"} {} Binary Infix None False GreaterTilde = GreaterTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2273\", \"y\"}} {\"GreaterTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} GreaterTilde[x, y] {} {\"\u2273\"} {} Binary Infix None False HumpDownHump = HumpDownHump 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u224e\", \"y\"}} {\"HumpDownHump\", \"[\", \"x\", \",\", \"y\", \"]\"} HumpDownHump[x, y] {} {\"\u224e\"} {} Binary Infix None False HumpEqual = HumpEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u224f\", \"y\"}} {\"HumpEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} HumpEqual[x, y] {} {\"\u224f\"} {} Binary Infix None False LeftTriangle = LeftTriangle 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22b2\", \"y\"}} {\"LeftTriangle\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftTriangle[x, y] {} {\"\u22b2\"} {} Binary Infix None False LeftTriangleBar = LeftTriangleBar 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u29cf\", \"y\"}} {\"LeftTriangleBar\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftTriangleBar[x, y] {} {\"\u29cf\"} {} Binary Infix None False LeftTriangleEqual = LeftTriangleEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22b4\", \"y\"}} {\"LeftTriangleEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftTriangleEqual[x, y] {} {\"\u22b4\"} {} Binary Infix None False Less = Less 360 290 = 290 50 = 50.0 390 {{\"expr1\", \"<\", \"expr2\"}} {\"Less\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Less[expr1, expr2] {} {\"<\"} {} Binary Infix None True LessEqual = LessEqual 360 290 = 290 50 = 50.0 390 = 390 {{\"expr1\", \"<=\", \"expr2\"}, {\"expr1\", \"\u2264\", \"expr2\"}} {\"LessEqual\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} LessEqual[expr1, expr2] {} {\"<=\", \"\u2264\"} {} Binary Infix None True LessEqualGreater = LessEqualGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22da\", \"y\"}} {\"LessEqualGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} LessEqualGreater[x, y] {} {\"\u22da\"} {} Binary Infix None False LessFullEqual = LessFullEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2266\", \"y\"}} {\"LessFullEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} LessFullEqual[x, y] {} {\"\u2266\"} {} Binary Infix None False LessGreater = LessGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2276\", \"y\"}} {\"LessGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} LessGreater[x, y] {} {\"\u2276\"} {} Binary Infix None False LessLess = LessLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u226a\", \"y\"}} {\"LessLess\", \"[\", \"x\", \",\", \"y\", \"]\"} LessLess[x, y] {} {\"\u226a\"} {} Binary Infix None False LessSlantEqual = LessSlantEqual 360 670 290 50.0 390 = 390 {{\"x\", \"\u2a7d\", \"y\"}} {\"LessEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} LessEqual[x, y] {} {\"\u2a7d\"} {} Binary Infix None False LessTilde = LessTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2272\", \"y\"}} {\"LessTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} LessTilde[x, y] {} {\"\u2272\"} {} Binary Infix None False NestedGreaterGreater = NestedGreaterGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2aa2\", \"y\"}} {\"NestedGreaterGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} NestedGreaterGreater[x, y] {} {\"\u2aa2\"} {} Binary Infix None False NestedLessLess = NestedLessLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2aa1\", \"y\"}} {\"NestedLessLess\", \"[\", \"x\", \",\", \"y\", \"]\"} NestedLessLess[x, y] {} {\"\u2aa1\"} {} Binary Infix None False NotCongruent = NotCongruent 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2262\", \"y\"}} {\"NotCongruent\", \"[\", \"x\", \",\", \"y\", \"]\"} NotCongruent[x, y] {} {\"\u2262\"} {} Binary Infix None False NotCupCap = NotCupCap 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u226d\", \"y\"}} {\"NotCupCap\", \"[\", \"x\", \",\", \"y\", \"]\"} NotCupCap[x, y] {} {\"\u226d\"} {} Binary Infix None False NotEqualTilde = NotEqualTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf400\", \"y\"}} {\"NotEqualTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} NotEqualTilde[x, y] {} {\"\uf400\"} {} Binary Infix None False NotGreater = NotGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u226f\", \"y\"}} {\"NotGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} NotGreater[x, y] {} {\"\u226f\"} {} Binary Infix None False NotGreaterEqual = NotGreaterEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2271\", \"y\"}} {\"NotGreaterEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotGreaterEqual[x, y] {} {\"\u2271\"} {} Binary Infix None False NotGreaterFullEqual = NotGreaterFullEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2269\", \"y\"}} {\"NotGreaterFullEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotGreaterFullEqual[x, y] {} {\"\u2269\"} {} Binary Infix None False NotGreaterGreater = NotGreaterGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf427\", \"y\"}} {\"NotGreaterGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} NotGreaterGreater[x, y] {} {\"\uf427\"} {} Binary Infix None False NotGreaterLess = NotGreaterLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2279\", \"y\"}} {\"NotGreaterLess\", \"[\", \"x\", \",\", \"y\", \"]\"} NotGreaterLess[x, y] {} {\"\u2279\"} {} Binary Infix None False NotGreaterSlantEqual = NotGreaterSlantEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf429\", \"y\"}} {\"NotGreaterSlantEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotGreaterSlantEqual[x, y] {} {\"\uf429\"} {} Binary Infix None False NotGreaterTilde = NotGreaterTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2275\", \"y\"}} {\"NotGreaterTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} NotGreaterTilde[x, y] {} {\"\u2275\"} {} Binary Infix None False NotHumpDownHump = NotHumpDownHump 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf402\", \"y\"}} {\"NotHumpDownHump\", \"[\", \"x\", \",\", \"y\", \"]\"} NotHumpDownHump[x, y] {} {\"\uf402\"} {} Binary Infix None False NotHumpEqual = NotHumpEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf401\", \"y\"}} {\"NotHumpEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotHumpEqual[x, y] {} {\"\uf401\"} {} Binary Infix None False NotLeftTriangle = NotLeftTriangle 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22ea\", \"y\"}} {\"NotLeftTriangle\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLeftTriangle[x, y] {} {\"\u22ea\"} {} Binary Infix None False NotLeftTriangleBar = NotLeftTriangleBar 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf412\", \"y\"}} {\"NotLeftTriangleBar\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLeftTriangleBar[x, y] {} {\"\uf412\"} {} Binary Infix None False NotLeftTriangleEqual = NotLeftTriangleEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22ec\", \"y\"}} {\"NotLeftTriangleEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLeftTriangleEqual[x, y] {} {\"\u22ec\"} {} Binary Infix None False NotLess = NotLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u226e\", \"y\"}} {\"NotLess\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLess[x, y] {} {\"\u226e\"} {} Binary Infix None False NotLessEqual = NotLessEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2270\", \"y\"}} {\"NotLessEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLessEqual[x, y] {} {\"\u2270\"} {} Binary Infix None False NotLessFullEqual = NotLessFullEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2268\", \"y\"}} {\"NotLessFullEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLessFullEqual[x, y] {} {\"\u2268\"} {} Binary Infix None False NotLessGreater = NotLessGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2278\", \"y\"}} {\"NotLessGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLessGreater[x, y] {} {\"\u2278\"} {} Binary Infix None False NotLessLess = NotLessLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf422\", \"y\"}} {\"NotLessLess\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLessLess[x, y] {} {\"\uf422\"} {} Binary Infix None False NotLessSlantEqual = NotLessSlantEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf424\", \"y\"}} {\"NotLessSlantEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLessSlantEqual[x, y] {} {\"\uf424\"} {} Binary Infix None False NotLessTilde = NotLessTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2274\", \"y\"}} {\"NotLessTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} NotLessTilde[x, y] {} {\"\u2274\"} {} Binary Infix None False NotNestedGreaterGreater = NotNestedGreaterGreater 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf428\", \"y\"}} {\"NotNestedGreaterGreater\", \"[\", \"x\", \",\", \"y\", \"]\"} NotNestedGreaterGreater[x, y] {} {\"\uf428\"} {} Binary Infix None False NotNestedLessLess = NotNestedLessLess 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf423\", \"y\"}} {\"NotNestedLessLess\", \"[\", \"x\", \",\", \"y\", \"]\"} NotNestedLessLess[x, y] {} {\"\uf423\"} {} Binary Infix None False NotPrecedes = NotPrecedes 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2280\", \"y\"}} {\"NotPrecedes\", \"[\", \"x\", \",\", \"y\", \"]\"} NotPrecedes[x, y] {} {\"\u2280\"} {} Binary Infix None False NotPrecedesEqual = NotPrecedesEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf42b\", \"y\"}} {\"NotPrecedesEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotPrecedesEqual[x, y] {} {\"\uf42b\"} {} Binary Infix None False NotPrecedesSlantEqual = NotPrecedesSlantEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22e0\", \"y\"}} {\"NotPrecedesSlantEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotPrecedesSlantEqual[x, y] {} {\"\u22e0\"} {} Binary Infix None False NotPrecedesTilde = NotPrecedesTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22e8\", \"y\"}} {\"NotPrecedesTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} NotPrecedesTilde[x, y] {} {\"\u22e8\"} {} Binary Infix None False NotRightTriangle = NotRightTriangle 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22eb\", \"y\"}} {\"NotRightTriangle\", \"[\", \"x\", \",\", \"y\", \"]\"} NotRightTriangle[x, y] {} {\"\u22eb\"} {} Binary Infix None False NotRightTriangleBar = NotRightTriangleBar 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf413\", \"y\"}} {\"NotRightTriangleBar\", \"[\", \"x\", \",\", \"y\", \"]\"} NotRightTriangleBar[x, y] {} {\"\uf413\"} {} Binary Infix None False NotRightTriangleEqual = NotRightTriangleEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22ed\", \"y\"}} {\"NotRightTriangleEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotRightTriangleEqual[x, y] {} {\"\u22ed\"} {} Binary Infix None False NotSucceeds = NotSucceeds 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2281\", \"y\"}} {\"NotSucceeds\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSucceeds[x, y] {} {\"\u2281\"} {} Binary Infix None False NotSucceedsEqual = NotSucceedsEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\uf42d\", \"y\"}} {\"NotSucceedsEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSucceedsEqual[x, y] {} {\"\uf42d\"} {} Binary Infix None False NotSucceedsSlantEqual = NotSucceedsSlantEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22e1\", \"y\"}} {\"NotSucceedsSlantEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSucceedsSlantEqual[x, y] {} {\"\u22e1\"} {} Binary Infix None False NotSucceedsTilde = NotSucceedsTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22e9\", \"y\"}} {\"NotSucceedsTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSucceedsTilde[x, y] {} {\"\u22e9\"} {} Binary Infix None False NotTilde = NotTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2241\", \"y\"}} {\"NotTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} NotTilde[x, y] {} {\"\u2241\"} {} Binary Infix None False NotTildeEqual = NotTildeEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2244\", \"y\"}} {\"NotTildeEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotTildeEqual[x, y] {} {\"\u2244\"} {} Binary Infix None False NotTildeFullEqual = NotTildeFullEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2247\", \"y\"}} {\"NotTildeFullEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotTildeFullEqual[x, y] {} {\"\u2247\"} {} Binary Infix None False NotTildeTilde = NotTildeTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2249\", \"y\"}} {\"NotTildeTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} NotTildeTilde[x, y] {} {\"\u2249\"} {} Binary Infix None False Precedes = Precedes 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u227a\", \"y\"}} {\"Precedes\", \"[\", \"x\", \",\", \"y\", \"]\"} Precedes[x, y] {} {\"\u227a\"} {} Binary Infix None False PrecedesEqual = PrecedesEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2aaf\", \"y\"}} {\"PrecedesEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} PrecedesEqual[x, y] {} {\"\u2aaf\"} {} Binary Infix None False PrecedesSlantEqual = PrecedesSlantEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u227c\", \"y\"}} {\"PrecedesSlantEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} PrecedesSlantEqual[x, y] {} {\"\u227c\"} {} Binary Infix None False PrecedesTilde = PrecedesTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u227e\", \"y\"}} {\"PrecedesTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} PrecedesTilde[x, y] {} {\"\u227e\"} {} Binary Infix None False Proportion = Proportion 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2237\", \"y\"}} {\"Proportion\", \"[\", \"x\", \",\", \"y\", \"]\"} Proportion[x, y] {} {\"\u2237\"} {} Binary Infix None False Proportional = Proportional 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u221d\", \"y\"}} {\"Proportional\", \"[\", \"x\", \",\", \"y\", \"]\"} Proportional[x, y] {} {\"\u221d\"} {} Binary Infix None False ReverseEquilibrium = ReverseEquilibrium 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u21cb\", \"y\"}} {\"ReverseEquilibrium\", \"[\", \"x\", \",\", \"y\", \"]\"} ReverseEquilibrium[x, y] {} {\"\u21cb\"} {} Binary Infix None False RightTriangle = RightTriangle 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22b3\", \"y\"}} {\"RightTriangle\", \"[\", \"x\", \",\", \"y\", \"]\"} RightTriangle[x, y] {} {\"\u22b3\"} {} Binary Infix None False RightTriangleBar = RightTriangleBar 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u29d0\", \"y\"}} {\"RightTriangleBar\", \"[\", \"x\", \",\", \"y\", \"]\"} RightTriangleBar[x, y] {} {\"\u29d0\"} {} Binary Infix None False RightTriangleEqual = RightTriangleEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u22b5\", \"y\"}} {\"RightTriangleEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} RightTriangleEqual[x, y] {} {\"\u22b5\"} {} Binary Infix None False Succeeds = Succeeds 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u227b\", \"y\"}} {\"Succeeds\", \"[\", \"x\", \",\", \"y\", \"]\"} Succeeds[x, y] {} {\"\u227b\"} {} Binary Infix None False SucceedsEqual = SucceedsEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2ab0\", \"y\"}} {\"SucceedsEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} SucceedsEqual[x, y] {} {\"\u2ab0\"} {} Binary Infix None False SucceedsSlantEqual = SucceedsSlantEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u227d\", \"y\"}} {\"SucceedsSlantEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} SucceedsSlantEqual[x, y] {} {\"\u227d\"} {} Binary Infix None False SucceedsTilde = SucceedsTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u227f\", \"y\"}} {\"SucceedsTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} SucceedsTilde[x, y] {} {\"\u227f\"} {} Binary Infix None False Tilde = Tilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u223c\", \"y\"}} {\"Tilde\", \"[\", \"x\", \",\", \"y\", \"]\"} Tilde[x, y] {} {\"\u223c\"} {} Binary Infix None False TildeEqual = TildeEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2243\", \"y\"}} {\"TildeEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} TildeEqual[x, y] {} {\"\u2243\"} {} Binary Infix None False TildeFullEqual = TildeFullEqual 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2245\", \"y\"}} {\"TildeFullEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} TildeFullEqual[x, y] {} {\"\u2245\"} {} Binary Infix None False TildeTilde = TildeTilde 360 290 = 290 50.0 390 = 390 {{\"x\", \"\u2248\", \"y\"}} {\"TildeTilde\", \"[\", \"x\", \",\", \"y\", \"]\"} TildeTilde[x, y] {} {\"\u2248\"} {} Binary Infix None False Unequal = Unequal 360 290 = 290 50 = 50.0 390 = 390 {{\"expr1\", \"!=\", \"expr2\"}, {\"expr1\", \"\u2260\", \"expr2\"}} {\"Unequal\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Unequal[expr1, expr2] {} {\"!=\", \"\u2260\"} {} Binary Infix None True DoubleVerticalBar = DoubleVerticalBar 350 280 = 280 50 \u2260 50.5 390 \u2260 385 {{\"expr1\", \"\u2225\", \"expr2\"}} {\"DoubleVerticalBar\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} DoubleVerticalBar[expr1, expr2] {} {\"\u2225\"} {} Binary Infix None False NotDoubleVerticalBar = NotDoubleVerticalBar 350 280 = 280 50 \u2260 50.5 390 \u2260 385 {{\"expr1\", \"\u2226\", \"expr2\"}} {\"NotDoubleVerticalBar\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} NotDoubleVerticalBar[expr1, expr2] {} {\"\u2226\"} {} Binary Infix None False NotVerticalBar = NotVerticalBar 350 280 = 280 50 \u2260 50.5 390 \u2260 385 {{\"expr1\", \"\uf3d1\", \"expr2\"}} {\"NotVerticalBar\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} NotVerticalBar[expr1, expr2] {} {\"\uf3d1\"} {} Binary Infix None False VerticalBar = VerticalBar 350 280 = 280 50 \u2260 50.5 390 \u2260 385 {{\"expr1\", \"\uf3d0\", \"expr2\"}} {\"VerticalBar\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} VerticalBar[expr1, expr2] {} {\"\uf3d0\"} {} Binary Infix None False DoubleLeftArrow = DoubleLeftArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21d0\", \"y\"}} {\"DoubleLeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleLeftArrow[x, y] {} {\"\u21d0\"} {} Binary Infix None False DoubleLeftRightArrow = DoubleLeftRightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21d4\", \"y\"}} {\"DoubleLeftRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleLeftRightArrow[x, y] {} {\"\u21d4\"} {} Binary Infix None False DoubleRightArrow = DoubleRightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21d2\", \"y\"}} {\"DoubleRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} DoubleRightArrow[x, y] {} {\"\u21d2\"} {} Binary Infix None False DownLeftRightVector = DownLeftRightVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2950\", \"y\"}} {\"DownLeftRightVector\", \"[\", \"x\", \",\", \"y\", \"]\"} DownLeftRightVector[x, y] {} {\"\u2950\"} {} Binary Infix None False DownLeftTeeVector = DownLeftTeeVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u295e\", \"y\"}} {\"DownLeftTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} DownLeftTeeVector[x, y] {} {\"\u295e\"} {} Binary Infix None False DownLeftVector = DownLeftVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21bd\", \"y\"}} {\"DownLeftVector\", \"[\", \"x\", \",\", \"y\", \"]\"} DownLeftVector[x, y] {} {\"\u21bd\"} {} Binary Infix None False DownLeftVectorBar = DownLeftVectorBar 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2956\", \"y\"}} {\"DownLeftVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} DownLeftVectorBar[x, y] {} {\"\u2956\"} {} Binary Infix None False DownRightTeeVector = DownRightTeeVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u295f\", \"y\"}} {\"DownRightTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} DownRightTeeVector[x, y] {} {\"\u295f\"} {} Binary Infix None False DownRightVector = DownRightVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21c1\", \"y\"}} {\"DownRightVector\", \"[\", \"x\", \",\", \"y\", \"]\"} DownRightVector[x, y] {} {\"\u21c1\"} {} Binary Infix None False DownRightVectorBar = DownRightVectorBar 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2957\", \"y\"}} {\"DownRightVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} DownRightVectorBar[x, y] {} {\"\u2957\"} {} Binary Infix None False LeftArrow = LeftArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2190\", \"y\"}} {\"LeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftArrow[x, y] {} {\"\u2190\"} {} Binary Infix None False LeftArrowBar = LeftArrowBar 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21e4\", \"y\"}} {\"LeftArrowBar\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftArrowBar[x, y] {} {\"\u21e4\"} {} Binary Infix None False LeftArrowRightArrow = LeftArrowRightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21c6\", \"y\"}} {\"LeftArrowRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftArrowRightArrow[x, y] {} {\"\u21c6\"} {} Binary Infix None False LeftRightArrow = LeftRightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2194\", \"y\"}} {\"LeftRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftRightArrow[x, y] {} {\"\u2194\"} {} Binary Infix None False LeftRightVector = LeftRightVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u294e\", \"y\"}} {\"LeftRightVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftRightVector[x, y] {} {\"\u294e\"} {} Binary Infix None False LeftTeeArrow = LeftTeeArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21a4\", \"y\"}} {\"LeftTeeArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftTeeArrow[x, y] {} {\"\u21a4\"} {} Binary Infix None False LeftTeeVector = LeftTeeVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u295a\", \"y\"}} {\"LeftTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftTeeVector[x, y] {} {\"\u295a\"} {} Binary Infix None False LeftVector = LeftVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21bc\", \"y\"}} {\"LeftVector\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftVector[x, y] {} {\"\u21bc\"} {} Binary Infix None False LeftVectorBar = LeftVectorBar 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2952\", \"y\"}} {\"LeftVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} LeftVectorBar[x, y] {} {\"\u2952\"} {} Binary Infix None False LowerLeftArrow = LowerLeftArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2199\", \"y\"}} {\"LowerLeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LowerLeftArrow[x, y] {} {\"\u2199\"} {} Binary Infix None False LowerRightArrow = LowerRightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2198\", \"y\"}} {\"LowerRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} LowerRightArrow[x, y] {} {\"\u2198\"} {} Binary Infix None False RightArrow = RightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2192\", \"y\"}} {\"RightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} RightArrow[x, y] {} {\"\u2192\"} {} Binary Infix None False RightArrowBar = RightArrowBar 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21e5\", \"y\"}} {\"RightArrowBar\", \"[\", \"x\", \",\", \"y\", \"]\"} RightArrowBar[x, y] {} {\"\u21e5\"} {} Binary Infix None False RightArrowLeftArrow = RightArrowLeftArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21c4\", \"y\"}} {\"RightArrowLeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} RightArrowLeftArrow[x, y] {} {\"\u21c4\"} {} Binary Infix None False RightTeeArrow = RightTeeArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21a6\", \"y\"}} {\"RightTeeArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} RightTeeArrow[x, y] {} {\"\u21a6\"} {} Binary Infix None False RightTeeVector = RightTeeVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u295b\", \"y\"}} {\"RightTeeVector\", \"[\", \"x\", \",\", \"y\", \"]\"} RightTeeVector[x, y] {} {\"\u295b\"} {} Binary Infix None False RightVector = RightVector 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u21c0\", \"y\"}} {\"RightVector\", \"[\", \"x\", \",\", \"y\", \"]\"} RightVector[x, y] {} {\"\u21c0\"} {} Binary Infix None False RightVectorBar = RightVectorBar 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2953\", \"y\"}} {\"RightVectorBar\", \"[\", \"x\", \",\", \"y\", \"]\"} RightVectorBar[x, y] {} {\"\u2953\"} {} Binary Infix None False ShortLeftArrow = ShortLeftArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\uf526\", \"y\"}} {\"ShortLeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} ShortLeftArrow[x, y] {} {\"\uf526\"} {} Binary Infix None False ShortRightArrow = ShortRightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\uf525\", \"y\"}} {\"ShortRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} ShortRightArrow[x, y] {} {\"\uf525\"} {} Binary Infix None False UpperLeftArrow = UpperLeftArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2196\", \"y\"}} {\"UpperLeftArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} UpperLeftArrow[x, y] {} {\"\u2196\"} {} Binary Infix None False UpperRightArrow = UpperRightArrow 340 270 = 270 50.6 380 = 380 {{\"x\", \"\u2197\", \"y\"}} {\"UpperRightArrow\", \"[\", \"x\", \",\", \"y\", \"]\"} UpperRightArrow[x, y] {} {\"\u2197\"} {} Binary Infix None False SameQ = SameQ 330 290 \u2260 260 51 = 51 370 {{\"expr1\", \"===\", \"expr2\"}} {\"SameQ\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} SameQ[expr1, expr2] {} {\"===\"} {} Binary Infix None True UnsameQ = UnsameQ 330 290 \u2260 260 51 = 51 370 {{\"expr1\", \"=!=\", \"expr2\"}} {\"UnsameQ\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} UnsameQ[expr1, expr2] {} {\"=!=\"} {} Binary Infix None True Distributed = Distributed 320 250 = 250 52 360 = 360 {{\"expr1\", \"\uf3d2\", \"expr2\"}} {\"Distributed\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Distributed[expr1, expr2] {} {\"\uf3d2\"} {} Binary Infix None True Element = Element 320 250 = 250 52 = 52 360 = 360 {{\"expr1\", \"\u2208\", \"expr2\"}} {\"Element\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Element[expr1, expr2] {} {\"\u2208\"} {} Binary Infix None True NotElement = NotElement 320 250 = 250 52 = 52 360 = 360 {{\"expr1\", \"\u2209\", \"expr2\"}} {\"NotElement\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} NotElement[expr1, expr2] {} {\"\u2209\"} {} Binary Infix None True NotReverseElement = NotReverseElement 320 250 = 250 52 360 = 360 {{\"x\", \"\u220c\", \"y\"}} {\"NotReverseElement\", \"[\", \"x\", \",\", \"y\", \"]\"} NotReverseElement[x, y] {} {\"\u220c\"} {} Binary Infix None False NotSquareSubset = NotSquareSubset 320 250 = 250 52 360 = 360 {{\"x\", \"\uf42e\", \"y\"}} {\"NotSquareSubset\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSquareSubset[x, y] {} {\"\uf42e\"} {} Binary Infix None False NotSquareSubsetEqual = NotSquareSubsetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u22e2\", \"y\"}} {\"NotSquareSubsetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSquareSubsetEqual[x, y] {} {\"\u22e2\"} {} Binary Infix None False NotSquareSuperset = NotSquareSuperset 320 250 = 250 52 360 = 360 {{\"x\", \"\uf42f\", \"y\"}} {\"NotSquareSuperset\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSquareSuperset[x, y] {} {\"\uf42f\"} {} Binary Infix None False NotSquareSupersetEqual = NotSquareSupersetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u22e3\", \"y\"}} {\"NotSquareSupersetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSquareSupersetEqual[x, y] {} {\"\u22e3\"} {} Binary Infix None False NotSubset = NotSubset 320 250 = 250 52 360 = 360 {{\"x\", \"\u2284\", \"y\"}} {\"NotSubset\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSubset[x, y] {} {\"\u2284\"} {} Binary Infix None False NotSubsetEqual = NotSubsetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u2288\", \"y\"}} {\"NotSubsetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSubsetEqual[x, y] {} {\"\u2288\"} {} Binary Infix None False NotSuperset = NotSuperset 320 250 = 250 52 360 = 360 {{\"x\", \"\u2285\", \"y\"}} {\"NotSuperset\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSuperset[x, y] {} {\"\u2285\"} {} Binary Infix None False NotSupersetEqual = NotSupersetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u2289\", \"y\"}} {\"NotSupersetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} NotSupersetEqual[x, y] {} {\"\u2289\"} {} Binary Infix None False ReverseElement = ReverseElement 320 250 = 250 52 360 = 360 {{\"x\", \"\u220b\", \"y\"}} {\"ReverseElement\", \"[\", \"x\", \",\", \"y\", \"]\"} ReverseElement[x, y] {} {\"\u220b\"} {} Binary Infix None False SquareSubset = SquareSubset 320 250 = 250 52 360 = 360 {{\"x\", \"\u228f\", \"y\"}} {\"SquareSubset\", \"[\", \"x\", \",\", \"y\", \"]\"} SquareSubset[x, y] {} {\"\u228f\"} {} Binary Infix None False SquareSubsetEqual = SquareSubsetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u2291\", \"y\"}} {\"SquareSubsetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} SquareSubsetEqual[x, y] {} {\"\u2291\"} {} Binary Infix None False SquareSuperset = SquareSuperset 320 250 = 250 52 360 = 360 {{\"x\", \"\u2290\", \"y\"}} {\"SquareSuperset\", \"[\", \"x\", \",\", \"y\", \"]\"} SquareSuperset[x, y] {} {\"\u2290\"} {} Binary Infix None False SquareSupersetEqual = SquareSupersetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u2292\", \"y\"}} {\"SquareSupersetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} SquareSupersetEqual[x, y] {} {\"\u2292\"} {} Binary Infix None False Subset = Subset 320 250 = 250 52 = 52 360 = 360 {{\"expr1\", \"\u2282\", \"expr2\"}} {\"Subset\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Subset[expr1, expr2] {} {\"\u2282\"} {} Binary Infix None False SubsetEqual = SubsetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u2286\", \"y\"}} {\"SubsetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} SubsetEqual[x, y] {} {\"\u2286\"} {} Binary Infix None False Superset = Superset 320 250 = 250 52 = 52 360 = 360 {{\"expr1\", \"\u2283\", \"expr2\"}} {\"Superset\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Superset[expr1, expr2] {} {\"\u2283\"} {} Binary Infix None False SupersetEqual = SupersetEqual 320 250 = 250 52 360 = 360 {{\"x\", \"\u2287\", \"y\"}} {\"SupersetEqual\", \"[\", \"x\", \",\", \"y\", \"]\"} SupersetEqual[x, y] {} {\"\u2287\"} {} Binary Infix None False Exists = Exists 310 240 = 240 53 = 53 350 = 350 {{\"\u2203\", \"expr\"}} {\"Exists\", \"[\", \"expr\", \"]\"} {\"\u2203\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. ForAll = ForAll 310 240 = 240 53 = 53 350 = 350 {{\"\u2200\", \"expr\"}} {\"ForAll\", \"[\", \"expr\", \"]\"} {\"\u2200\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. NotExists = NotExists 310 240 = 240 53 = 53 350 = 350 {{\"\u2204\", \"expr\"}} {\"NotExists\", \"[\", \"expr\", \"]\"} {\"\u2204\"} {} {} Unary Prefix Right True Usage and Parse may not be correct. Not = Not 300 230 = 230 54 = 54 340 = 340 {{\"!\", \"expr\"}, {\"\u00ac\", \"expr\"}} {\"Not\", \"[\", \"expr\", \"]\"} Not[expr] {\"!\", \"\u00ac\"} {} {} Unary Prefix Right True And = And 290 215 \u2260 220 55 = 55 330 = 330 {{\"expr1\", \"&&\", \"expr2\"}, {\"expr1\", \"\u2227\", \"expr2\"}} {\"And\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} And[expr1, expr2] {} {\"&&\", \"\u2227\"} {} Binary Infix None True Nand = Nand 290 215 \u2260 220 55 = 55 330 = 330 {{\"expr1\", \"\u22bc\", \"expr2\"}} {\"Nand\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Nand[expr1, expr2] {} {\"\u22bc\"} {} Binary Infix None True Xnor = Xnor 280 215 = 215 56 = 56 325 = 325 {{\"expr1\", \"\uf4a2\", \"expr2\"}} {\"Xnor\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Xnor[expr1, expr2] {} {\"\uf4a2\"} {} Binary Infix None True Xor = Xor 280 215 = 215 56 = 56 325 = 325 {{\"expr1\", \"\u22bb\", \"expr2\"}} {\"Xor\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Xor[expr1, expr2] {} {\"\u22bb\"} {} Binary Infix None True Nor = Nor 270 215 \u2260 210 57 = 57 320 = 320 {{\"expr1\", \"\u22bd\", \"expr2\"}} {\"Nor\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Nor[expr1, expr2] {} {\"\u22bd\"} {} Binary Infix None True Or = Or 270 215 \u2260 210 57 = 57 320 = 320 {{\"expr1\", \"||\", \"expr2\"}, {\"expr1\", \"\u2228\", \"expr2\"}} {\"Or\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Or[expr1, expr2] {} {\"||\", \"\u2228\"} {} Binary Infix None True Equivalent = Equivalent 260 205 = 205 58 = 58 315 = 315 {{\"expr1\", \"\u29e6\", \"expr2\"}} {\"Equivalent\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Equivalent[expr1, expr2] {} {\"\u29e6\"} {} Binary Infix None True RoundImplies = RoundImplies 250 240 \u2260 200 59 310 = 310 {{\"expr1\", \"\u2970\", \"expr2\"}} {\"RoundImplies\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} RoundImplies[expr1, expr2] {} {\"\u2970\"} {} Binary Infix Right False Implies = Implies 250 200 = 200 59 = 59 310 = 310 {{\"expr1\", \"\uf523\", \"expr2\"}} {\"Implies\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Implies[expr1, expr2] {} {\"\uf523\"} {} Binary Infix Right True Conditioned = Conditioned 240 195 = 195 59.5 305 = 305 {{\"expr1\", \"\uf3d3\", \"expr2\"}} {\"Conditioned\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Conditioned[expr1, expr2] {} {\"\uf3d3\"} {} Binary Infix None True DoubleRightTee = DoubleRightTee 230 190 = 190 59.6 300 = 300 {{\"expr1\", \"\u22a8\", \"expr2\"}} {\"DoubleRightTee\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} DoubleRightTee[expr1, expr2] {} {\"\u22a8\"} {} Binary Infix Right False RightTee = RightTee 230 190 = 190 59.6 300 = 300 {{\"expr1\", \"\u22a2\", \"expr2\"}} {\"RightTee\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} RightTee[expr1, expr2] {} {\"\u22a2\"} {} Binary Infix Right False DoubleLeftTee = DoubleLeftTee 220 190 = 190 60 = 60 300 = 300 {{\"expr1\", \"\u2ae4\", \"expr2\"}} {\"DoubleLeftTee\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} DoubleLeftTee[expr1, expr2] {} {\"\u2ae4\"} {} Binary Infix Left False DownTee = DownTee 220 190 = 190 60 = 60 300 = 300 {{\"expr1\", \"\u22a4\", \"expr2\"}} {\"DownTee\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} DownTee[expr1, expr2] {} {\"\u22a4\"} {} Binary Infix Left False LeftTee = LeftTee 220 190 = 190 60 = 60 300 = 300 {{\"expr1\", \"\u22a3\", \"expr2\"}} {\"LeftTee\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} LeftTee[expr1, expr2] {} {\"\u22a3\"} {} Binary Infix Left False UpTee = UpTee 220 190 = 190 60 = 60 390 = 390 {{\"expr1\", \"\u22a5\", \"expr2\"}} {\"UpTee\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} UpTee[expr1, expr2] {} {\"\u22a5\"} {} Binary Infix Left False Perpendicular = Perpendicular 220 190 = 190 60 390 = 390 {{\"expr1\", \"\u27c2\", \"expr2\"}} {\"Perpendicular\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Perpendicular[expr1, expr2] {} {\"\u27c2\"} {} Binary Infix None False SuchThat = SuchThat 210 180 = 180 61 = 61 290 = 290 {{\"expr1\", \"\u220d\", \"expr2\"}} {\"SuchThat\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} SuchThat[expr1, expr2] {} {\"\u220d\"} {} Binary Infix Right False Repeated = Repeated 200 170 = 170 62 = 62 280 {{\"expr\", \"..\"}} {\"Repeated\", \"[\", \"expr\", \"]\"} Repeated[expr] {} {\"..\"} {} Unary Postfix Left True RepeatedNull = RepeatedNull 200 170 = 170 62 = 62 280 {{\"expr\", \"...\"}} {\"RepeatedNull\", \"[\", \"expr\", \"]\"} RepeatedNull[expr] {} {\"...\"} {} Unary Postfix Left True Alternatives = Alternatives 190 160 = 160 63 \u2260 64 276 {{\"expr1\", \"|\", \"expr2\"}} {\"Alternatives\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Alternatives[expr1, expr2] {} {\"|\"} {} Binary Infix None True Pattern = Pattern 190 150 = 150 64 = 64 275 {{\"symb\", \":\", \"expr\"}} {\"Pattern\", \"[\", \"symb\", \",\", \"expr\", \"]\"} Pattern[symb, expr] {} {\":\"} {} Binary Infix Non True Optional = Optional 190 140 = 140 64 = 64 270 {{\"patt\", \":\", \"expr\"}} {\"Optional\", \"[\", \"patt\", \",\", \"expr\", \"]\"} Optional[patt, expr] {} {\":\"} {} Binary Infix Non True StringExpression = StringExpression 180 135 = 135 65 = 65 265 {{\"expr1\", \"~~\", \"expr2\"}} {\"StringExpression\", \"[\", \"expr1\", \",\", \"exrp2\", \"]\"} StringExpression[expr1, expr2] {} {\"~~\"} {} Binary Infix None True Condition = Condition 170 130 = 130 66 = 66 260 {{\"expr1\", \"/;\", \"expr2\"}} {\"Condition\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Condition[expr1, expr2] {} {\"/;\"} {} Binary Infix Left True TwoWayRule = TwoWayRule 160 125 = 125 66.5 255 = 255 {{\"expr1\", \"<->\", \"expr2\"}, {\"expr1\", \"\uf120\", \"expr2\"}} {\"TwoWayRule\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} TwoWayRule[expr1, expr2] {} {\"<->\", \"\uf120\"} {} Binary Infix Right True RuleDelayed = RuleDelayed 150 120 = 120 67 = 67 250 = 250 {{\"expr1\", \":>\", \"expr2\"}, {\"expr1\", \"\uf51f\", \"expr2\"}} {\"RuleDelayed\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} RuleDelayed[expr1, expr2] {} {\":>\", \"\uf51f\"} {} Binary Infix Right True Rule = Rule 140 120 = 120 67 \u2260 67.5 250 = 250 {{\"expr1\", \"->\", \"expr2\"}, {\"expr1\", \"\uf522\", \"expr2\"}} {\"Rule\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Rule[expr1, expr2] {} {\"->\", \"\uf522\"} {} Binary Infix Right True ReplaceAll = ReplaceAll 130 110 = 110 68 = 68 240 {{\"expr1\", \"/.\", \"expr2\"}} {\"ReplaceAll\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} ReplaceAll[expr1, expr2] {} {\"/.\"} {} Binary Infix Left True ReplaceRepeated = ReplaceRepeated 130 110 = 110 68 = 68 240 {{\"expr1\", \"//.\", \"expr2\"}} {\"ReplaceRepeated\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} ReplaceRepeated[expr1, expr2] {} {\"//.\"} {} Binary Infix Left True TimesBy = TimesBy 120 100 = 100 69 = 69 230 {{\"expr1\", \"*=\", \"expr2\"}} {\"TimesBy\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} TimesBy[expr1, expr2] {} {\"*=\"} {} Binary Infix Right True SubtractFrom = SubtractFrom 120 100 = 100 69 = 69 230 {{\"expr1\", \"-=\", \"expr2\"}} {\"SubtractFrom\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} SubtractFrom[expr1, expr2] {} {\"-=\"} {} Binary Infix Right True DivideBy = DivideBy 120 100 = 100 69 = 69 230 {{\"expr1\", \"/=\", \"expr2\"}} {\"DivideBy\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} DivideBy[expr1, expr2] {} {\"/=\"} {} Binary Infix Right True AddTo = AddTo 120 100 = 100 69 = 69 230 {{\"expr1\", \"+=\", \"expr2\"}} {\"AddTo\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} AddTo[expr1, expr2] {} {\"+=\"} {} Binary Infix Right True Function = Function 110 90 = 90 70 = 70 220 {{\"expr\", \"&\"}} {\"Function\", \"[\", \"expr\", \"]\"} Function[expr] {} {\"&\"} {} Unary Postfix Left True Colon = Colon 100 80 = 80 71 = 71 205 = 205 {{\"expr1\", \"\u2236\", \"expr2\"}} {\"Colon\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Colon[expr1, expr2] {} {\"\u2236\"} {} Binary Infix None False FunctionApplyPostfix \u2260 Postfix 90 70 = 70 72 204 {{\"expr1\", \"//\", \"expr2\"}} {\"expr2\", \"[\", \"expr1\", \"]\"} expr2[expr1] {} {\"//\"} {} Binary Infix Left True Postfix[f[x]] will display as x//f. Precedence identifies Postfix with this operator. VerticalSeparator = VerticalSeparator 80 60 = 60 73 = 73 202 \u2260 203 {{\"expr1\", \"\uf432\", \"expr2\"}} {\"VerticalSeparator\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} VerticalSeparator[expr1, expr2] {} {\"\uf432\"} {} Binary Infix None False Therefore = Therefore 70 50 = 50 74 \u2260 73.5 201 \u2260 202 {{\"expr1\", \"\u2234\", \"expr2\"}} {\"Therefore\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Therefore[expr1, expr2] {} {\"\u2234\"} {} Binary Infix Right False Precedence of Therefore and Because are swapped in notebook versus ToExpression. Because = Because 60 50 = 50 74 = 74 201 = 201 {{\"expr1\", \"\u2235\", \"expr2\"}} {\"Because\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Because[expr1, expr2] {} {\"\u2235\"} {} Binary Infix Left False Precedence of Therefore and Because are swapped in notebook versus ToExpression. ParameterizedFunction \u2260 Function 50 90 \u2260 40 75 = 75 190 = 190 {{\"expr1\", \"\uf4a1\", \"expr2\"}} {\"Function\", \"[\", \"{\", \"expr1\", \"}\", \",\", \"expr2\", \"]\"} Function[expr1, expr2] {} {\"\uf4a1\"} {} Binary Infix Right True The arrow form of Function. Set = Set 50 40 = 40 75 = 75 190 {{\"expr1\", \"=\", \"expr2\"}} {\"Set\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} Set[expr1, expr2] {} {\"=\"} {} Binary Infix Right True SetDelayed = SetDelayed 50 40 = 40 75 = 75 190 {{\"expr1\", \":=\", \"expr2\"}} {\"SetDelayed\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} SetDelayed[expr1, expr2] {} {\":=\"} {} Binary Infix Right True TagSet = TagSet 50 670 40 75 = 75 190 {{\"symb\", \"/:\", \"expr1\", \"=\", \"expr2\"}} {\"TagSet\", \"[\", \"symb\", \",\", \"expr1\", \"]\"} TagSet[symb, expr1, expr2] {} {\"/:\"} {\"=\"} Ternary Infix Right True TagSetDelayed = TagSetDelayed 50 670 40 75 = 75 190 {{\"symb\", \"/:\", \"expr1\", \":=\", \"expr2\"}} {\"TagSetDelayed\", \"[\", \"symb\", \",\", \"expr1\", \"]\"} TagSetDelayed[symb, expr1, expr2] {} {\"/:\"} {\":=\"} Ternary Infix Right True TagUnset = TagUnset 50 670 40 75 = 75 190 {{\"symb\", \"/;\", \"expr\", \"=.\"}} {\"TagUnset\", \"[\", \"symb\", \",\", \"expr\", \"]\"} Unset[Condition[symb, expr]] {} {\"/;\"} {\"=.\"} Binary Infix Right True Unset = Unset 50 670 40 75 = 75 190 {{\"expr\", \"=.\"}} {\"Unset\", \"[\", \"expr\", \"]\"} Unset[expr] {} {\"=.\"} {} Unary Postfix Left True UpSet = UpSet 50 40 = 40 75 = 75 190 {{\"expr1\", \"^=\", \"expr2\"}} {\"UpSet\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} UpSet[expr1, expr2] {} {\"^=\"} {} Binary Infix Right True UpSetDelayed = UpSetDelayed 50 40 = 40 75 = 75 190 {{\"expr1\", \"^:=\", \"expr2\"}} {\"UpSetDelayed\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} UpSetDelayed[expr1, expr2] {} {\"^:=\"} {} Binary Infix Right True Put = Put 40 30 = 30 76 = 76 180 {{\"expr\", \">>\", \"filename\"}} {\"Put\", \"[\", \"expr\", \",\", \"\", \"filename\"} Put[expr, \"filename\"] {} {\">>\"} {} Binary Infix Left True PutAppend = PutAppend 40 30 = 30 76 = 76 180 {{\"expr\", \">>>\", \"filename\"}} {\"PutAppend\", \"[\", \"expr\", \",\", \"\", \"filename\"} PutAppend[expr, \"filename\"] {} {\">>>\"} {} Binary Infix Left True CompoundExpression = CompoundExpression 30 10 = 10 77 = 77 170 {{\"expr1\", \";\", \"expr2\"}} {\"CompoundExpression\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} CompoundExpression[expr1, expr2] {} {\";\"} {} Binary Infix None True CompoundExpressionNull \u2260 CompoundExpression 30 10 = 10 77 = 77 170 {{\"expr1\", \";\", \"expr2\", \";\"}} {\"CompoundExpression\", \"[\", \"expr1\", \",\", \"expr2\", \"]\"} CompoundExpression[expr1, expr2, Null] {} {\";\"} {} Unary Postfix Left True FormBox = FormBox 20 670 5 78 = 78 160 {{\"expr1\", \"\\\\`\", \"expr2\"}} {\"FormBox\", \"[\", \"expr2\", \",\", \"expr1\", \"]\"} {} {\"\\\\`\"} {} Binary Infix Missing[\"Unknown\"] True ImplicitSequence \u2260 Comma 10 670 755 79 1 = 1 {{\"expr1\", \"\uf765\", \"expr2\"}, {\"expr1\", \",\", \"expr2\"}} {\"AngleBracket\", \"[\", \"expr\", \",\", \"\u2026\", \"]\"} expr1, expr2 {} {\"\uf765\", \",\"} {} Binary Infix None True Operator Notations includes usages with invisible unicode characters.","title":"OperatorTableHTML"},{"location":"Specification/Syntax/Pseudo-operators/","text":"Pseudo-operators \u00b6 There are several tokens in Wolfram Language whose status as an operator is questionable. String-related characters like \" and \\ < \u2026 \\ > . The line continuation pseudo-operator \\ . The character representation operators: \\[name] , \\ : nn , \\ . nnnn and the catalog of escaped characters \\ r , \\ t , etc. The newline escape character \\ n , which can cancel an implicit multiplication. The number representation pseudo-operators: ^^ , *^ , and `` . The single ` character appears in two distinct contexts: to specify precision in a number literal and as a context path separator. Both uses might be considered lexical rather than operational. The comment matchfix operator (* \u2026 *) . The Get and Put operates << and >> . The information operators ?? and ? . These are pseudo-operators in the sense that their function is write-time representation rather than runtime computation. They are lexemes that are such basic units of the language that they may be processed by Mathematica during or even prior to the lexical analysis phase of the code parsing process similar to how C/C++ compiler drivers preprocess #define , #include , and other preprocessor directives before sending the result to the compiler. These sorts of language elements are not unique to Wolfram Language, of course, and language tool authors generally make choices about how to handle them based on their syntactic role within the language and what simplifies the software engineering task.","title":"Pseudo Operators"},{"location":"Specification/Syntax/Pseudo-operators/#pseudo-operators","text":"There are several tokens in Wolfram Language whose status as an operator is questionable. String-related characters like \" and \\ < \u2026 \\ > . The line continuation pseudo-operator \\ . The character representation operators: \\[name] , \\ : nn , \\ . nnnn and the catalog of escaped characters \\ r , \\ t , etc. The newline escape character \\ n , which can cancel an implicit multiplication. The number representation pseudo-operators: ^^ , *^ , and `` . The single ` character appears in two distinct contexts: to specify precision in a number literal and as a context path separator. Both uses might be considered lexical rather than operational. The comment matchfix operator (* \u2026 *) . The Get and Put operates << and >> . The information operators ?? and ? . These are pseudo-operators in the sense that their function is write-time representation rather than runtime computation. They are lexemes that are such basic units of the language that they may be processed by Mathematica during or even prior to the lexical analysis phase of the code parsing process similar to how C/C++ compiler drivers preprocess #define , #include , and other preprocessor directives before sending the result to the compiler. These sorts of language elements are not unique to Wolfram Language, of course, and language tool authors generally make choices about how to handle them based on their syntactic role within the language and what simplifies the software engineering task.","title":"Pseudo-operators"},{"location":"Specification/Syntax/tasks/","text":"- [ ] Primitives * [ ] Strings * [x] [Number representations](Number-representations.md) * [ ] Symbols (identifiers) * [ ] Special character representations - [ ] Operators * [ ] Variadic forms * [ ] Operators with a built-in meaning * [x] [List of all operators with precedence, associativity, affix, and arity](../Syntax/OperatorTable.md) * [ ] Two-dimensional \"operators\" * [ ] FullForm (M-expressions) * [x] [Pseudo-operators](Pseudo-operators.md) - [ ] Formatting and whitespace - [ ] Box sublanguage - [ ] Issues and inconsistencies * [ ] Precedence * [ ] FullForm interpretation * [ ] Nonexpression objects (\"atomic functions\") * [ ] Bugs","title":"Tasks"}]}